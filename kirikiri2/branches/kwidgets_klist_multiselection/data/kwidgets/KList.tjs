//
// $Id: KList.tjs,v 1.7 2007/09/14 17:13:00 m2 Exp $
//


/*----------------------------------------------------------------------
 * リスト項目リネーム時のテキストエディット
 ----------------------------------------------------------------------*/
class KLabelEdit extends KTextInput {
  var item;
  var minLabelWidth = 1;

  function KLabelEdit(item) {
    this.item = item;
    minLabelWidth = item.minLabelWidth;

    // リストに収まる範囲の大きさでテキストエディットを作成。
    var rootRect = item.root.viewingRect;
    var rect = item.labelRect;
    rect.left += item.left - 5;
    rect.top += item.top - 3;
    rect.width = rootRect.width - rect.left + rootRect.left;
    rect.height = item.size - item.root.spaceVertical + 8;
    super.KTextInput(item.root.window,
                     rect.width, rect.height,
                     item.labelTextType);

    parent = item.root;
    fontFace = item.root.fontFace;

    setPos(rect.left, rect.top);
    value = item.label;

    text.focus();
    text.onWindowDeactivate = this.onWindowDeactivate;
  }

  function finalize {
    super.finalize(...);
  }

  // フォーカスが外れたらキャンセル扱い
  function onChildBlur {
    super.onChildBlur(...);
    text.cancelValue();
  }

  // ENTER押したら内容を反映
  function onEnter {
    if (! item.isAcceptRename(value))
      return;
    if (value.length >= minLabelWidth) {
      var oldLabel = item.label;
      item.label = value;
      item.onRename(oldLabel, value);
    }
    asyncCaller.call(parent.removeLabelEdit);
  }

  // キャンセルしたら無かったことに
  function onCancel {
    asyncCaller.call(parent.removeLabelEdit);
  }

  // スクロールされちゃまずいんでホイールは食う。
  function onMouseWheel {
  }

  function onWindowDeactivate {
    text.cancelValue();
  }    
};   
    

/**----------------------------------------------------------------------
 * リストビュー
 ----------------------------------------------------------------------*/
class KList extends KVirtualWidget
{
  var isRoot = true;
  var depth = -1;
  var root;
  var slideWidth = 12;
  var drawItemList = [];
  var treeWidth, treeHeight;
  var childList = [];
  var selection = void;
  var selectionRect = [ 0, 0, 0, 0 ];
  var labelEdit = void;
  var labelTextType = TEXT_SYMBOL;
  var marginalWidth, marginalHeight;
  var _focusOnSelect;
  var selectionLayer;
  var iconDeposit;
  var curDragTargetItem;
  var curDragTargetItemAcceptPacket = false;
  var curPointItem = void;
  var relocateRequired = false;
  var reconstructRequired = false;
  var resizeRequired = false;

  /*------------------------------
   * リストビュー
   *
   * 入れ子が可能なリストビュー。
   * リスト本体である KList と、リストアイテム KListItem から鳴る。
   *
   * KList は KWidget を継承したクラスだが、KListItem は KWidget では無い。
   * メモリ節約の観点から、KListItem は画面に表示される時のみ
   * 内部的に proxy widget を作る設計になっている。
   * だが、マウス関連やドラッグ＆ドロップ関連のイベントのほとんどは
   * proxy widget から KListItem に転送されるため、 KListItem を
   * KWidget 継承クラスとみなして扱っても実質的に問題は無い。
   *
   * @param window ウィンドウ
   * @param name 名前
   ------------------------------*/
  function KList(window, name = "") {
    super.KVirtualWidget(window, name);
    focusable = window.defaultFocusable;
    hitThreshold = 0;
    root = this;
    selectionLayer = new global.Layer(window, this);
    marginalWidth = marginalHeight = 1000;
    setMinMaxSize(0, 0, marginalWidth, marginalHeight);
    _focusOnSelect = true;
    iconDeposit = %[];
  }

  /*------------------------------
   * ファイナライザ
   ------------------------------*/
  function finalize {
    discardArray(childList);
    super.finalize(...);
  }

  /**------------------------------
   * 最低限のサイズを設定する
   *
   * リスト項目が少なくても最低限広げられる
   * 「最低最大サイズ」を決定する。
   * デフォルト値は1000x1000
   *
   * @param w 幅
   * @param h 高さ
   ------------------------------*/
  function setMarginalSize(w, h) {
    marginalWidth = w;
    marginalHeight = h;
    requireResize();
  }

  /**------------------------------
   * 子アイテムを追加する
   *
   * @param item アイテム
   ------------------------------*/
  function add(item) {
    item.depth = -1;
    item.parent = this;
    childList.add(item);
    requireReconstruct();
  }

  /**------------------------------
   * 子アイテムを挿入する
   *
   * @param index インデックス
   * @param item アイテム
   ------------------------------*/
  function insert(index, item) {
    item.depth = -1;
    item.parent = this;
    childList.insert(index, item);
    requireReconstruct();
  }

  /**------------------------------
   * 子アイテムを削除する
   * 
   * @param item アイテム
   * @param doInvalidate invalidateするかどうか
   ------------------------------*/
  function remove(item, doInvalidate = true) {
    if (! (item isvalid))
      return void;

    if (item == root.selection
        || (root.selection && item.isAncestorOf(root.selection))) {
      root.selectItem(void);
      var i = item.index;
      childList.remove(item);
      if (childList.count != 0) {
        if (i > childList.count - 1)
          i--;
        childList[i].select();
      } 
    } else {
      childList.remove(item);
    }

    item._root = void;
    item.parent = void;

    if (doInvalidate)
      invalidate item;

    requireReconstruct();
  }

  /**------------------------------
   * 子アイテムを全て削除する
   *
   * @param doInvalidate 取り除いた子ウィジェットを無効化するか
   ------------------------------*/
  function removeAll(doInvalidate = true)
  {
    while(childList.count > 0)
      {
        var child = childList[0];
        childList.remove(child);
        if(doInvalidate)
          {
            invalidate child;
          }
        else
          {
            child._root = void;
            child.parent = void;
          }
      }
    selection = void;
    requireReconstruct();
  }

  /**------------------------------
   * 子アイテムをカウントする
   * 
   * @return 子アイテム数
   ------------------------------*/
  property childCount {
    getter {
      return childList.count;
    }
  }

  /**------------------------------
   * 子アイテムを参照する
   *
   * @param index インデックス
   * @return 子アイテム
   ------------------------------*/
  function childAt(index) {
    return childList[index];
  }

  /**------------------------------
   * 子孫アイテムから特定の名前を持った子アイテムを捜す
   * 
   * @param name アイテムの名前
   * @return アイテム
   ------------------------------*/
  function find(name) {
    if (this.name === name)
      return this;
    for (var i = 0; i < childList.count; i++) {
      var child = childList[i];
      var widget = child.find(name);
      if (widget)
        return widget;
    }
    return void;
  }

  /*------------------------------
   * 選択アイテムのインデックス
   ------------------------------*/
  property selectionIndex {
    getter {
      return drawItemList.find(selection);
    }
  }

  /*------------------------------
   * 選択が変更された時に呼ばれる
   *
   * @param selection セレクション
   ------------------------------*/
  function onSelect(item) {
  }

  // 祖先であるかどうか判定
  function isAncestorOf(item) {
    for (; item != root; item = item.parent) {
      if (item == this)
        return true;
    }
    return false;
  }

  // 子孫であるかどうか判定
  function isDescendantOf(item) {
    return item.isAncestorOf(this);
  }

  /**------------------------------
   * 子孫ウィジェットの一覧
   ------------------------------*/
  property descendants {
    getter {
      var result = [];
      for (var i = 0; i < childList.count; i++) {
        var child = childList[i];
        result.add(child);
        var childDescendants = child.descendants;
        for (var j = 0; j < childDescendants.count; j++)
          result.add(childDescendants[j]);
      }
      return result;
    }
  }

  /**------------------------------
   * セレクト時にフォーカス時を移動するかどうか
   *
   * @param v セレクト時にフォーカス時を移動するかどうか
   * @return セレクト時にフォーカス時を移動するかどうか
   ------------------------------*/
  property focusOnSelect {
    getter {
      return _focusOnSelect;
    }
    setter(v) {
      _focusOnSelect = v;
    }
  }

  // アイコンをロードしてキャッシュする
  function findIcon(filename) {
    if (typeof(iconDeposit[filename]) == "undefined") {
      var layer = iconDeposit[filename] = new global.Layer(window, this);
      layer.loadImages(filename);
      layer.setSizeToImageSize();
    }
    return iconDeposit[filename];
  }

  // y座標からアイテムを検索
  function findItem(y) {
    var index = findItemIndex(y);
    if (index < 0)
      return void;
    else
      return drawItemList[index];
  }

  // y座標からアイテムのインデックスを検索
  function findItemIndex(y) {
    var begin, end, mid;
    begin = 0, end = drawItemList.count;

    while (begin < end) {
      mid = int((begin + end) / 2);
      var item = drawItemList[mid];
      if (y < item.top) 
        end = mid;
      else if (y >= item.top + item.size)
        begin = mid + 1;
      else {
        return mid;
      }
    }

    return drawItemList.count - 1;
  }

  // 領域内のアイテムを描画
  function onDraw(left, top, width, height) {
    fillRect(left, top, width, height, WIN_WHITE);
    if (drawItemList.count) {
      var from = findItemIndex(top);
      var to = findItemIndex(top + height - 1);
      
      for (var i = from; i <= to; i++) {
        var item = drawItemList[i];
        if (item.selected) 
          fillRect(0, item.top, width, item.height, focused ? WIN_SELECTED : WIN_BG);
        if (item === curDragTargetItem
            && curDragTargetItemAcceptPacket)
          fillRect(0, item.top, width, item.height, 0xFFFF0000);
        item.onDraw(...);
      }
    }
  }

  function requireResize {
    resizeRequired = true;
    update();
  }

  function requireRelocate {
    relocateRequired = true;
    resizeRequired = true;
    update();
  }

  function requireReconstruct {
    reconstructRequired = true;
    relocateRequired = true;
    resizeRequired = true;
    update();
  }

  // 選択アイテムが閉じてしまったら
  // 上階層のアイテムを選択し直す
  function invalidateSelectio() {
    if (selection !== void) {
      if (selection isvalid) {
        if (! selection.visible) {
          var newSelection = selection;
          while (! newSelection.visible)
            newSelection = newSelection.parent;
          selectItem(newSelection);
        }
      } else {
        selectItem(void);
      }
    }
  }

  // 描画更新
  function onPaint() { 
    var i;

    // ツリーを再構築
    if (reconstructRequired) {
      reconstructItems();
    }
    // ツリーサイズを再計算
    if (relocateRequired) {
      relocateItems();
    }

    // 選択アイテムが閉じてしまったら
    // 上階層のアイテムを選択し直す
    invalidateSelectio();

    // サイズを再設定
    if (resizeRequired) {
      setMinMaxSize(treeWidth, treeHeight,
                    Math.max(marginalWidth, treeWidth),
                    Math.max(marginalHeight, treeHeight));
    }

    // 選択アイテムの背景色を変更
    redrawAll();

    // フラグリセット
    relocateRequired = false;
    reconstructRequired = false;
    resizeRequired = false;
  }

  // アイテムの再構築
  function reconstructItems() {
    var i, num, child, v, item;

    // 既存アイテムは一旦全て不可視に設定する
    for (var i = 0; i < drawItemList.count; i++)
      if (drawItemList[i] isvalid)
        drawItemList[i].visible = false;

    // ツリーをたどって、表示するアイテムを表示し直す
    drawItemList = [];

    var stack = [];
    
    i = 0;
    item = this;
    num = item.childList.count;
    v = true;

    var sum = 0;

    if (num == 0)
      return;
    for (;;) {
      child = item.childList[i];
      if (v) {
        child.visible = true;
        drawItemList.add(child);
      } if (child.hasChild
            && child.opened) {
        if (i + 1 < num)
          stack.add([ item, i + 1, num, v ]);
        item = child;
        i = 0;
        num = item.childList.count;
        v = v && item.opened;
        continue;
      }
      if (++i < num)
        continue;
      if (stack.count == 0)
        break;
      var a = stack[stack.count - 1];
      stack.erase(stack.count - 1);
      item = a[0];
      i = a[1];
      num = a[2];
      v = a[3];
    }
  }

  // アイテムのサイズ再配置
  function relocateItems() {
    treeWidth = 0;
    treeHeight = 0;

    for (var i = 0; i < drawItemList.count; i++) {
      var item = drawItemList[i];
      item.locate(item.depth * slideWidth, treeHeight);
      treeWidth = Math.max(treeWidth,
                           item.width + item.depth * slideWidth);
      treeHeight += item.height;
    }
  }      

  // 特定のアイテムを選択する
  function selectItem(item) {
    if (selection === item)
      return;

    // 祖先アイテムを参照
    var prevAncestors = [], curAncestors = [];
    if (selection !== void) {
      prevAncestors = selection.ancestors;
      prevAncestors.insert(0, selection);
    }
    if (item !== void) {
      curAncestors = item.ancestors;
      curAncestors.insert(0, item);
    }

    // 祖先アイテムが共通の部分に関しては、更新を呼ばない
    while (prevAncestors.count 
           && curAncestors.count
           && prevAncestors[prevAncestors.count - 1] === curAncestors[curAncestors.count - 1]) {
      prevAncestors.erase(prevAncestors.count - 1);
      curAncestors.erase(curAncestors.count - 1);
    }

    var prevSelection = selection;
    if (prevSelection !== void) {
      prevSelection.onDeselect();
      for (var i = 0; i < prevAncestors.count; i++)
        prevAncestors[i].onDescendantDeselect();
    }
    selection = void;
    if (prevSelection !== void)
      prevSelection.redraw();

    selection = item;
    if (selection === void) {
      return;
    }
    selection.redraw();
    drawSelection();
    if (selection !== void) {
      for (var i = curAncestors.count - 1; i >= 0; i--)
        curAncestors[i].onDescendantSelect();
      selection.onSelect(prevSelection);
    }

    onSelect(selection);
  }

  // 選択アイテムの背景を選択色で描画する
  function drawSelection {
    if (selection !== void)
      selection.redraw();
  }

  // フォーカス時反応
  function onFocus {
    // セレクション再描画
    drawSelection();
  }

  // フォーカス失った時の反応
  function onBlur {
    // セレクション再描画
    drawSelection();
  }

  // セレクションを注視する
  function seeSelection {
    asyncCaller.callOnce(this.doSeeSelection, this);
  }

  function doSeeSelection {
    if (selection !== void) {
      noticeRect(selection.left, selection.top, 
                 selection.width, selection.height);
    }
  }

  // マウス押されたらその位置のアイテムをセレクト
  function onMouseDown(x, y, button, shift) {
    super.onMouseDown(...);
    if (button == mbMiddle)
      return;
    var index = findItemIndex(y);
    if (index >= 0) {
      selectItem(drawItemList[index]);
      selection.onMouseDown(x, y - selection.top, button, shift);
    }
    focus();
  }

  function onMouseUp(x, y, button, shift) {
    super.onMouseUp(...);
    var item = findItemIndex(y);
    if (item !== void)
      item.onMouseUp(x, y - item.top, button, shift);
  }

  function onMouseUp(x, y, button, shift) {
    super.onMouseUp(...);
    var item = findItem(y);
    if (item !== void)
      item.onMouseUp(x, y - item.top, button, shift);
  }

  function onMouseMove(x, y, shift) {
    super.onMouseMove(...);
    var item = findItem(y);

    if (item !== curPointItem) {
      if (curPointItem !== void)
        curPointItem.onMouseLeave();
      curPointItem = item;
      if (curPointItem !== void)
        curPointItem.onMouseEnter();
    }

    if (item !== void) {
      hint = item.hint;
      status = item.status;
      item.onMouseMove(x, y - item.top, shift);
    } else {
      hint = "";
      status = "";
    }
  }

  function onDoubleClick(x, y) {
    if (selection !== void) {
      selection.onDoubleClick(x, y - selection.top);
    }
  }

  function onDragEnter(x, y, shift) {
    if (selection !== void) {
      selection.onDragEnter(x - selection.left, y - selection.top, shift);
    }
  }

  function onDragMove(x, y, shift) {
    if (selection !== void) {
      selection.onDragMove(x - selection.left, y - selection.top, shift);
    }
  }
  
  function onDragLeave(x, y, shift) {
    if (selection !== void) {
      selection.onDragLeave(x, y - selection.top, shift);
    }
  }

  function isPacketAcceptable(packet) {
    return true;
  }

  function onPacketMove(x, y, packet, shift) {
    var prevDragTargetItem = curDragTargetItem;
    var prevDragTargetItemAcceptPacket = curDragTargetItemAcceptPacket;
    curDragTargetItem = findItem(y);
    if (curDragTargetItem !== prevDragTargetItem) {
      curDragTargetItemAcceptPacket = false;
      if (prevDragTargetItemAcceptPacket) {
        prevDragTargetItem.onPacketLeave();
        prevDragTargetItem.redraw();
      }
      if (curDragTargetItem !== void) {
        curDragTargetItemAcceptPacket = curDragTargetItem.isPacketAcceptable(packet);
        if (curDragTargetItemAcceptPacket) {
          curDragTargetItem.onPacketEnter();
          curDragTargetItem.redraw();
        }
      }
    }
    if (curDragTargetItemAcceptPacket)
      curDragTargetItem.onPacketMove(x, y - curDragTargetItem.top, packet, shift);
  }

  function onPacketLeave(x, y, packet, shift) {
    if (curDragTargetItem !== void
        && curDragTargetItemAcceptPacket) {
      curDragTargetItemAcceptPacket = false;
      curDragTargetItem.onPacketLeave();
      curDragTargetItem.redraw();
      curDragTargetItem = void;
    }
  }

  function isPacketConfirmed(x, y, packet, shift) {
    return curDragTargetItemAcceptPacket;
  }

  function onPacketDrop(x, y, packet, shift) {
    var target = findItem(y);
    target.onPacketDrop(x - target.left, y - target.top, packet, shift);
  }

  function onPacketCancel(packet) {
    if (selection !== void) {
      selection.onPacketCancel(packet);
    }
  }

  // キー反応
  function onKeyDownSuper(key, shift) {
    if (key == VK_DOWN
        || key == VK_UP
        || key == VK_RIGHT
        || key == VK_LEFT)
      return;
    else
      super.onKeyDown(...);
  }

  function onKeyDown(key, shift) {
    if (selection === void) {
      super.onKeyDown(...);
      return;
    }
    var selectionIndex = this.selectionIndex;
    if (key == VK_DOWN
        && ! (shift & (ssAlt | ssCtrl | ssShift))) {
      if (selectionIndex + 1 < drawItemList.count) {
        selectItem(drawItemList[selectionIndex + 1]);
        seeSelection();
      }
    } else if (key == VK_UP
               && ! (shift & (ssAlt | ssCtrl | ssShift))) {
      if (selectionIndex > 0) {
        selectItem(drawItemList[selectionIndex - 1]);
        seeSelection();
      }
    } else if (key == VK_RIGHT
               && ! (shift & (ssAlt | ssCtrl | ssShift))) {
      if (selection.childList.count == 0) {
        return;
      }
      if (selection.opened) {
        selectItem(selection.childList[0]);
      } else {
        selection.opened = true;
      }
    } else if (key == VK_LEFT
               && ! (shift & (ssAlt | ssCtrl | ssShift))) {
      if (selection.childList.count != 0
          && selection.opened) {
        selection.opened = false;
        seeSelection();
      } else if (selection.parent != root) {
        selectItem(selection.parent);
        seeSelection();
      }
    } else if (key == VK_F2) {
      renameSelection();
    } else {
      selection.onKeyDown(...);
    }
  }

  // キー反応
  function onKeyPress(key) {
    switch (key) {
    case '+': {
      selection.opened = true;
      break;
    }
    case '-': {
      selection.opened = false;
      break;
    }
    case "*": {
      selection.openDescendants();
      selection.opened = true;
      break;
    }
    }
  }

  // 選択中のアイテムをリネームする
  function renameSelection {
    if (selection !== void
        && selection.labelEditable) {
      seeSelection();
      labelEdit = new KLabelEdit(selection);
      onBeginLabelEdit();
    }
  }

  // リネームを終了
  function removeLabelEdit {
    onFinishLabelEdit();
    discard(labelEdit);
    focus(selection);
  }

  function onBeginLabelEdit {
  }

  function onFinishLabelEdit {
  }

  // enabled==trueならそのまま表示
  function onNodeEnabled {
    canvas.opacity = 255;
    opacity = 255;
  } 

  // enabled=falseなら半透明で表示
  function onNodeDisabled {
    canvas.opacity = 64;
    opacity = 64;
  }
};

/**----------------------------------------------------------------------
 * リストアイテム
 ----------------------------------------------------------------------*/
class KListItem
{
  var isRoot = false;
  var _depth;
  var _opened;
  var _root;
  var parent;
  var _visible = false;
  var childList = [];
  var _labelEditable = false;
  var _minLabelWidth = 1;
  var _labelTextType = TEXT_SYMBOL;
  var name;
  var _size;
  var _icon;
  var _label;
  var _hint;
  var _status;
  // ウィジェット
  var _nameCache = %[];
  var _fontColor = 0xFFFFFFFF;
  var _fontBold = false;
  var left, top, width, height;
  var toggleWidth;
  var iconWidth;
  var labelWidth;
  var iconLayerList;
  var ownIconLayerList;

  /**------------------------------
   * コンストラクタ
   * 
   * @param label ラベル
   * @param name 名前
   ------------------------------*/
  function KListItem(label = "", name = "") {
    _opened = false;
    this.name = name;
    _depth = -1;
    _label = label;
    _hint = "";
    _status = "";
    _icon = [];
    iconLayerList = [];
    ownIconLayerList = [];    // missing を有効にする
    Scripts.setCallMissing(this);
  }

  /*------------------------------
   * ファイナライザ
   ------------------------------*/
  function finalize {
    discardArray(childList);
    discard(layer);
    discardArray(ownIconLayerList);
  }

  
  /*------------------------------
   * 旧仕様と互換性を保つためだけのダミープロパティ
   ------------------------------*/
  property layer {
    getter {
      return %[ left: left, top: top, width: width, height: height ];
    }
  }

  /**------------------------------
   * クラスツリー
   *
   * @return 自分自身の属するクラスツリーを配列で返す
   ------------------------------*/
  property classTrees {
    getter {
      return Scripts.getClassNames(this);
    }
  }

  /**------------------------------
   * クラス名
   *
   * @return 自分自身のクラス名を返す
   ------------------------------*/
  property className {
    getter {
      return Scripts.getClassNames(this)[0];
    }
  }

  /**------------------------------
   * ラベルがリネーム可能かどうか
   * 
   * @param v リネーム可能？
   * @return リネーム可能？
   ------------------------------*/
  property labelEditable {
    getter {
      return _labelEditable;
    }
    setter(v) {
      _labelEditable = v;
      return _labelEditable;
    }
  }

  /**------------------------------
   * ラベルのテキストタイプ
   *
   * リネーム時に設定可能な テキストのタイプを
   * TEXT_ANY, TEXT_DIGIT, TEXT_SYMBOL のいずれかより設定する
   * 
   * @param v テキストタイプ
   * @return テキストタイプ
   ------------------------------*/
  property labelTextType {
    getter {
      return _labelTextType;
    }
    setter(v) {
      _labelTextType = v;
      return _labelTextType;
    }
  }

  /**------------------------------
   * ラベルの最小文字数
   *
   * リネーム時に設定可能なラベルの最小文字数を設定する
   * 
   * @param v 最小文字数
   * @return 最小文字数
   ------------------------------*/
  property minLabelWidth {
    getter {
      return _minLabelWidth;
    }
    setter(v) {
      _minLabelWidth = v;
      return _minLabelWidth;
    }
  }

  /**------------------------------
   * アイテムの縦幅
   *
   * 指定しないと、MList の fontHeight から spaceVertical から自動設定される
   *
   * @param v 縦幅
   * @return 縦幅
   ------------------------------*/
  property size {
    getter {
      if (_size == 0) {
        var r = root;
        if (r)
          _size = root.fontHeight + root.spaceVertical;
      }
      return _size;
    }
      
    setter(v) {
      _size = v;
      if (visible) {
        updateSize();
        requireRelocate();
      }
      return;
    }
  }

  /**------------------------------
   * ラベル
   * 
   * @param value ラベル
   * @return ラベル
   ------------------------------*/
  property label {
    getter {
      return _label;
    }
    setter (value) {
      if (_label == value)
        return;
      _label = value;
      if (_visible) {
        updateSize();
        requireRelocate();
      }
    }
  }

  /**------------------------------
   * フォントカラー
   * 
   * @param value カラー
   * @return カラー
   ------------------------------*/
  property fontColor {
    getter {
      return _fontColor;
    }
    setter (value) {
      if (_fontColor == value)
        return;
      _fontColor = value;
      if (_visible) {
        redraw();
      }
    }
  }

  /**------------------------------
   * フォントボールド
   * 
   * @param value ボールド
   * @return ボールド
   ------------------------------*/
  property fontBold {
    getter {
      return _fontBold;
    }
    setter (value) {
      if (_fontBold == value)
        return;
      _fontBold = value;
      if (_visible) {
        updateSize();
        requireRelocate();
      }
    }
  }

  /**------------------------------
   * ヒント
   *
   * @param value ヒント
   ------------------------------*/
  property hint {
    getter {
      return _hint;
    }
    setter(v) {
      _hint = v;
    }
  }
  
  /**------------------------------
   * ステータス
   *
   * @param value ステータス
   ------------------------------*/
  property status {
    getter {
      return _status;
    }
    setter(v) {
      _status = v;
    }
  }
  
  /**------------------------------
   * アイコン
   *
   * ラベルの前方に描画されるアイコンを設定する。
   * voidを設定するとアイコンは消去される。
   * アイコンがクリックされると onIconClick() が呼ばれる。
   *
   * @param value アイコンファイル名
   * @return アイコンファイル名
   ------------------------------*/
  property icon {
    getter {
      return _icon[0];
    }
    setter(value) {
      if (value == void)
        icons = [];
      else
        icons = [ value ];
    }
  }

  /**------------------------------
   * アイコンリスト
   *
   * ラベルの前方に描画されるアイコンを複数設定する。
   * 設定したアイコンは左から順番に並んで表示される。
   * アイコンがクリックされると onIconClick() が呼ばれる。
   * onIconClickの引数でどのアイコンが押されたかを判別できる。
   *
   * @param value アイコンファイル名配列
   * @return アイコンファイル名配列
   ------------------------------*/
  property icons {
    getter {
      return duplicateStruct(_icon);
    }
    setter(value) {
      _icon = value;
      if (! visible)
        return;
      updateIconLayerList();
      updateSize();
      requireRelocate();
    }
  }

  function updateIconLayerList() {
    discardArray(ownIconLayerList);
    iconLayerList = [];
    ownIconLayerList = [];
    
    for (var i = 0; i < _icon.count; i++) {
      var icon = _icon[i];
      var iconLayer;
      var own = false;
      if (icon instanceof "Layer") {
        iconLayer = new global.Layer(root.window, root);
        iconLayer.assignImages(icon);
        iconLayer.setSize(icon.width, icon.height);
        own = true;
      } else if (typeof(icon) == "Object") {
        iconLayer = new global.Layer(root.window, root);
        icon(iconLayer);
        own = true;
      } else {
        iconLayer = root.findIcon(icon);
      }
      iconLayerList.add(iconLayer);
      if (own)
        ownIconLayerList.add(iconLayer);
    }
  }

  property hasIcon {
    getter {
      return _icon.count > 0;
    }
  }

  /**------------------------------
   * アイコンが押された時に呼ばれるフック関数
   *
   * @param iconIndex アイコンインデックス
   ------------------------------*/
  function onIconClick(iconIndex) {
    select();
    root.focus();
  } 

  /*------------------------------
   * depth
   ------------------------------*/
  property depth {
    setter (v) {
      _depth = v;
      if (v == -1)
        for (var i = 0; i < childList.count; i++)
          childList[i].depth = v;
    }
    getter {
      if (_depth < 0) {
        if (parent !== void)
          _depth = parent.depth + 1;
      }
      return _depth;
    }
  }

  /**------------------------------
   * 子アイテムを追加する
   *
   * @param item アイテム
   ------------------------------*/
  function add(item) {
    item.depth = -1;
    item.parent = this;
    childList.add(item);
    requireReconstruct();
  }

  /**------------------------------
   * 子アイテムを挿入する
   *
   * @param index インデックス
   * @param item アイテム
   ------------------------------*/
  function insert(index, item) {
    item.depth = -1;
    item.parent = this;
    childList.insert(index, item);
    requireReconstruct();
  }

  /**------------------------------
   * 子アイテムを削除する
   * 
   * @param item アイテム
   * @param doInvalidate invalidateするかどうか
   ------------------------------*/
  function remove(item, doInvalidate = true) {
    if (! (item isvalid))
      return void;

    if (item == root.selection
        || (root.selection && item.isAncestorOf(root.selection))) {
      root.selectItem(void);
      var i = item.index;
      childList.remove(item);
      if (childList.count != 0) {
        if (i > childList.count - 1)
          i--;
        childList[i].select();
      }  else {
        select();
      }
    } else {
      childList.remove(item);
    }

    item._root = void;
    item.parent = void;

    if (doInvalidate)
      invalidate item;

    requireReconstruct();
  }

  /**------------------------------
   * 子アイテムを全て削除する
   *
   * @param doInvalidate 取り除いた子ウィジェットを無効化するか
   ------------------------------*/
  function removeAll(doInvalidate = true)
  {
    if (root !== void
        && root.selection 
        && this.isAncestorOf(root.selection)) 
      root.selectItem(void);
    while(childList.count > 0)
      {
        var child = childList[0];
        childList.remove(child);
        if(doInvalidate)
          {
            invalidate child;
          }
        else
          {
            child._root = void;
            child.parent = void;
          }
      }
    requireReconstruct();
  }

  /**------------------------------
   * 自分自身を削除する
   *
   * @param doInvalidate invalidateするかどうか
   ------------------------------*/
  function removeSelf(doInvalidate = true) {
    asyncCaller.call(parent.remove, this, doInvalidate);
  }

  /**------------------------------
   * 子持ちかどうか判定する
   *
   * @return 子持ち？
   ------------------------------*/
  property hasChild {
    getter {
      return childList.count != 0;
    }
  }

  /**------------------------------
   * 子アイテムをカウントする
   * 
   * @return 子アイテム数
   ------------------------------*/
  property childCount {
    getter {
      return childList.count;
    }
  }

  /**------------------------------
   * 子アイテムを参照する
   *
   * @param index インデックス
   * @return 子アイテム
   ------------------------------*/
  function childAt(index) {
    return childList[index];
  }

  /**------------------------------
   * 子孫アイテムから特定の名前を持った子ウィジェットを捜す
   * 
   * @param name 名前
   ------------------------------*/
  function find(name) {
    if (this.name === name)
      return this;
    for (var i = 0; i < childList.count; i++) {
      var child = childList[i];
      var widget = child.find(name);
      if (widget)
        return widget;
    }
    return void;
  }

  /**------------------------------
   * 子孫アイテムから特定の名前を持った子ウィジェットを捜します
   *
   * find関数を経由せずに、オブジェクトのプロパティ扱いで名前を指定して
   * 子孫アイテム中のウィジェットを参照することが出来ます。
   *
   * パフォーマンスの都合で、グローバルに同名のシンボルが存在する場合は
   * 優先的にそちらを見に行くという挙動をするので注意。
   ------------------------------*/
  function missing(get_or_set, name, value) {
    if (! get_or_set) {
      if (typeof(global[name]) != "undefined")
        return false;
      if (typeof(_nameCache[name]) != "undefined") {
        var widget = _nameCache[name];
        if (widget isvalid
            && widget.name == name) {
          *value = widget;
          return true;
        } else {
          delete _nameCache[name];
        }
      }
      var widget = find(name);
      if (widget) {
        _nameCache[name] = widget;
        *value = widget;
        return true;
      }
    }
    return false;
  }

  /**------------------------------
   * 自分自身のインデックス
   * 
   * リストの何番目にいるか。
   *
   * @param value インデックス
   * @return インデックス
   ------------------------------*/
  property index {
    getter {
      return parent.childList.find(this);
    }

    setter(value) {
      var curIndex = index;
      if (curIndex == value)
        return;
      parent.childList.erase(curIndex);
      parent.childList.insert(value, this);
      requireReconstruct();
    }
  }

  /**------------------------------
   * アイテムを「選択」状態にする
   ------------------------------*/
  function select {
    root.selectItem(this);
    root.seeSelection();
  }

  /**------------------------------
   * 選択されているか？
   * @return 選択されているか？
   ------------------------------*/
  property selected {
    getter {
      return root !== void
        && root.selection === this;
    }
  }

  /**------------------------------
   * アイテムが選択状態になった時に呼ばれるフック関数
   ------------------------------*/
  function onSelect {
  }

  /**------------------------------
   * アイテムが非選択状態になった時に呼ばれるフック関数
   ------------------------------*/
  function onDeselect {
  }

  /**------------------------------
   * (自分を含む)子孫アイテムが選択状態になった時に呼ばれるフック関数
   ------------------------------*/
  function onDescendantSelect {
  }

  /**------------------------------
   * (自分を含む)子孫アイテムが非選択状態になった時に呼ばれるフック関数
   ------------------------------*/
  function onDescendantDeselect {
  }

  /**------------------------------
   * 子持ちの時のトグル状態を変更する
   *
   * @param o 開閉
   * @return 開閉
   ------------------------------*/
  property opened {
    getter {
      return _opened;
    }
    setter(o) {
      if (_opened == o)
        return;
      _opened = o;
      requireReconstruct();
    }
  }

  /**------------------------------
   * 子孫アイテムをまとめて開く
   *------------------------------*/
  function openDescendants {
    var i, desc = descendants;

    for (i = 0; i < desc.count; i++) {
      if (desc[i].hasChild) {
        desc[i].opened = true;
      }
    }
  }

  /**------------------------------
   * ユーザーに値を入力させてラベルをリネームする
   * (F2を押した時と同様の動作)
   *------------------------------*/
  function renameAsUserInput {
    select();
    root.renameSelection();
  }    

  /**------------------------------
   * ラベルをリネームする
   * 
   * 引数 labelを指定すると、ラベル変更後に onRename 関数が呼ばれる。
   * (ラベル変更後にフックをかける仕組)
   * 
   * @param label リネームするラベル
   ------------------------------*/
  function rename(label) {
    var oldLabel = this.label;
    this.label = label;
    this.onRename(oldLabel, label);
  }

  /**------------------------------
   * ラベルにリネーム許可を与えるか判定する
   *
   * renameAsUserInput を使ったリネーム時に、
   * 指定された名前を受け入れていいかどうかを判定する
   * ユーザー定義関数。
   * デフォルトの実装では常にtrueを返す
   *
   * @param label 判定するラベル
   * @return 受け入れるならtrueを、拒否するならfalseを返す。
   ------------------------------*/
  function isAcceptRename(label) {
    return true;
  }

  /**------------------------------
   * リネーム時に呼ばれるフック関数
   * 
   * @param oldLabl 旧ラベル
   * @param newLabel 新ラベル
   ------------------------------*/
  function onRename(oldLabel, newLabel)
  {
  }

  /*------------------------------
   * 各種ウィジェットイベントフック関数。
   * 引数の詳細は KWidgetを参照されたし
   ------------------------------*/
  // キーダウン
  function onKeyDown(key, shift) {
    root.onKeyDownSuper(...);
  }

  // マウスダウン
  function onMouseDown(x, y, button, shift) {
    if (button == mbLeft
        && hasChild
        && inToggle(x, y)) {
      if (! opened
          && (shift & ssCtrl))
        openDescendants();
      opened = ! opened;
      return;
    }
    if (button == mbLeft
        && hasIcon
        && inIcon(x, y)) {
      onIconClick(iconIndexAt(x));
      return;
    }
    if (button == mbLeft) {
      onClick(x, y, shift);
    }
    if (button == mbRight) {
      onRightClick(x, y, shift);
    }
  }
  
  // マウスムーブ
  function onMouseMove(x, y, button, shift) {
  }

  // マウスアップ
  function onMouseUp(x, y, button, shift) {
  }

  // マウスエンター
  function onMouseEnter() {
  }

  // マウスリーブ
  function onMouseLeave() {
  }

  // 右クリック
  function onRightClick(x, y, shift) {
  }

  // 左クリック
  function onClick(x, y) {
  }

  // ドラッグエンター
  function onDragEnter(x, y, shift) {
  }

  // ドラッグムーブ
  function onDragMove(x, y, shift) {
  }

  // ドラッグリーブ
  function onDragLeave(x, y, shift) {
  }

  // パケットのドラッグ開始
  function beginDragPacket(packet) {
    root.beginDragPacket(packet);
  }

  // パケットの受け入れ判定
  function isPacketAcceptable(packet) {
    return false;
  }

  // パケット侵入
  function onPacketEnter(x, y, packet, shift) {
    // 背景色を変更
  }

  // パケットムーブ
  function onPacketMove(x, y, packet, shift) {
  }

  // パケット離脱
  function onPacketLeave(x, y, packet, shift) {
  }

  // パケットドロップ
  function onPacketDrop(x, y, packet, shift) {
  }

  // パケットキャンセル
  function onPacketCancel(packet) {
  }

  /*------------------------------
   * フック関数ここまで
   ------------------------------*/

  // アイテムの可視
  property visible {
    getter {
      return _visible;
    }

    setter (v) {
      if (_visible == v)
        return;
      _visible = v;
      if (_visible) {
        updateIconLayerList();
        updateSize();
      }
    }
  }

  // トグルの表示に要する幅
  // 位置設定
  function locate(x, y) {
    left = x;
    top = y;
  }

  function updateSize() {
    height = 0;
    toggleWidth = root.findIcon("k_list_open").width + 4;;
    height = Math.max(height, root.findIcon("k_list_open").height);
    iconWidth = 4;
    for (var i = 0; i < iconLayerList.count; i++) {
      iconWidth += iconLayerList[i].width;
      height = Math.max(iconLayerList[i].height);
    }
    root.font.bold = _fontBold;
    labelWidth = root.font.getTextWidth(label);
    width = toggleWidth + iconWidth + labelWidth;
    height = Math.max(height, size);
  }

  function inToggle(x, y) {
    x -= left;
    return x >= 0 && x < toggleWidth;
  }

  function inIcon(x, y) {
    x -= left;
    return x >= toggleWidth && x < toggleWidth + iconWidth;
  }

  function inLabel(x, y) {
    x -= left;
    return x >= toggleWidth + iconWidth && x < width;
  }

  // アイコンインデックスを特定
  function iconIndexAt(x) {
    x -= left;
    x -= toggleWidth + 2;
    var i;
    for (i = 0; i < iconLayerList.count - 1; i++)
      if (x < iconLayerList[i].width)
        return i;
      else
        x -= iconLayerList[i].width;
    return i;
  }

  function onDoubleClick(x, y) {
    if (! inToggle(x, y)
        && hasChild)
      opened = ! opened;
  }
  
  // 祖先アイテム一覧
  property ancestors {
    getter {
      var a, item;

      a = [];
      
      for (item = this.parent; item && ! item.isRoot; item = item.parent)
        a.add(item);

      return a;
    }
  }

  // 祖先であるかどうか判定
  function isAncestorOf(item) {
    for (; ! item.isRoot; item = item.parent) {
      if (item == this)
        return true;
    }
    return false;
  }

  // 子孫であるかどうか判定
  function isDescendantOf(item) {
    return item.isAncestorOf(this);
  }

  // 子孫アイテム一覧
  property descendants {
    getter {
      var i, num, child, item;
      var stack = [];
      i = 0;
      var retval = [];
      item = this;
      num = item.childList.count;
      if (num == 0)
        return [];
      for (;;) {
        child = item.childList[i];
        retval.add(child);
        if (child.hasChild) {
          if (i + 1 < num)
            stack.add([ item, i + 1, num ]);
          item = child;
          i = 0;
          num = item.childList.count;
          continue;
        }
        if (++i < num)
          continue;
        if (stack.count == 0)
          break;
        var a = stack[stack.count - 1];
        stack.erase(stack.count - 1);
        item = a[0];
        i = a[1];
        num = a[2];
      }
      return retval;
    }
  }

  // ルートアイテムを参照する
  property root {
    getter {
      if (_root === void
          && parent !== void)
        _root = parent.root;
      return _root;
    }
  }

  // windowを参照する
  property window {
    getter {
      return root.window;
    }
  }

  // 再配置を要求
  function requireRelocate {
    if (root) {
      root.requireRelocate();
    }
  }

  // 再構築を要求
  function requireReconstruct {
    if (root) {
      root.requireReconstruct();
    }
  }

  // アイコンレイヤ
  function iconLayerAt(index) {
    var layer = _icon[index];
    if (layer instanceof "Layer")
      return layer;
    else
      return root.icon(layer);
  }

  function redraw() {
    if (visible)
      root.onDraw(0, top, root.width, size);
  }

  function onDraw {
    var root = this.root;
    root.font.bold = _fontBold;
    root.drawText(left + toggleWidth + iconWidth, top + root.spaceVertical / 2, label, fontColor,
                  255, true, 2048, WIN_WHITE, 2.5);
    
    if (childCount) {
      var toggle = root.findIcon(opened ? "k_list_open" : "k_list_close");
      root.blendRect(left + 2, top + (size - toggle.height) / 2,
                     toggle,
                     0, 0, 
                     toggle.width, toggle.height);
    }
    if (_icon.count) {
      var x = left + toggleWidth + 2;
      for (var i = 0; i < _icon.count; i++) {
        var iconLayer = iconLayerList[i];
        root.blendRect(x, top + (size - iconLayer.height) / 2, iconLayer, 0, 0, iconLayer.width, iconLayer.height);
        x += iconLayer.width;
      }
    }
  }

  // ラベル矩形
  property labelRect {
    getter {
      return %[ left:(toggleWidth + iconWidth), top:0, 
                width:width - (toggleWidth + iconWidth), height:size];
    }
  }

  /**------------------------------
   * 「値」が変わった時に呼ばれるフック関数
   *
   * 「値」を持つウィジェットで、値が変更された時に呼ばれます。
   * デフォルトでは、parent の onChildValueModifiedを呼ぶように設定されています。
   *
   * @param newValue 新規の値
   * @param oldValue 変更前の値
   ------------------------------*/
  function onValueModified(newValue, oldValue) {
    if (parent !== void)
      parent.onChildValueModified(this, newValue, oldValue);
  }

  /**------------------------------
   * 子ウィジェットの「値」が変わった時に呼ばれるフック関数
   *
   * 子ウィジェットの「値」値が変更された時に呼ばれます。
   * デフォルトでは、さらに parent の onChildValueModifiedを呼ぶように設定されています。
   * どこかのウィジェットが関数をオーバーライドして処理を行わない限り、
   * 値変更の通知は KWindow まで届きます。
   *
   * @param newValue 新規の値
   * @param oldValue 変更前の値
   ------------------------------*/
  function onChildValueModified(child, newValue, oldValue) {
    if (parent !== void)
      parent.onChildValueModified(...);
  }
};
