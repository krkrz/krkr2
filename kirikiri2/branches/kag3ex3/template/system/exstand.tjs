// 立ち絵処理拡張

// 立ち絵アニメパターン用切り替え時間(最短の場合)
var eyeFlipTime = 60;
// 目ぱち頻度 ※eyeFlipTime が下がるとその分上がるので注意以下一応補正入り
var eyeFlipFreq = 0.025 * eyeFlipTime / 100;

// 口パクアニメパターン用切り替え時間(最短の場合)
// 目用の時間の整数倍にしておくと更新タイミング的に良い
var lipFlipTime = 180;

// psdlayer 読み込み
KAGLoadScript("psdlayer.tjs");

// サウンドバッファ処理
if (typeof WaveSoundBuffer.setDefaultAheads == "undefined") {
	WaveSoundBuffer.enableGetSample = false;
	try {
		Plugins.link("getSample.dll");
		// サンプル先行取得の値（口パクズレ軽減用）
		WaveSoundBuffer.setDefaultAheads((int)(200 * 44.1));
		WaveSoundBuffer.enableGetSample = true;
	} catch {
		//System.inform("getSample.dll の読み込みに失敗しました");
	}
}

// 立ち絵基本情報の読み込み
var allStandInfoMap, allStandInfoList;
var allStandLevelMap;
var allStandAnimMap;
{

// csv パーサプラグインの読み込み
if (global.CSVParser === void) {
    Plugins.link("csvParser.dll");
}
// shrinkCopyプラグイン読み込み
if (typeof global.Layer.shrinkCopy == "undefined") {
	try { Plugins.link("shrinkCopy.dll"); } catch {}
}

/**
 * 立ち絵定義ファイル読み出しパーサ
 */
class ExStandInfoParser extends CSVParser 
{
	var result, chlist = [];

	/**
	 * コンストラクタ
	 */
	function ExStandInfoParser() {
		super.CSVParser(...);
		result = %[];
	}

    /**
     * 行毎に呼び出される
     * @param columns カラムデータ(Array)
     * @param lineNo 論理行番号(1〜)
     */
	function doLine(columns, lineNo) {
		if (columns.count > 0 && columns[0].length > 0 && columns[0].charAt(0) != "#") {
			var chname   = columns[0];
			var posename = columns[1];
			var filename = columns[2];
			var xoffset  = +columns[3];
			var yoffset  = +columns[4];
			var facezoom = columns.count > 5 &&  columns[5].trim().length > 0 ? +columns[5] : 100;
			var facexoff = columns.count > 6 &&  columns[6].trim().length > 0 ? +columns[6] : 0;
			var faceyoff = columns.count > 7 &&  columns[7].trim().length > 0 ? +columns[7] : 0;
			var emoRev   = columns.count > 8 &&  columns[8].trim().length > 0 ? +columns[8] : 0;

			var infofile = filename + "_info.txt"; 
			if (!Storages.isExistentStorage(infofile)) {
				dm("データ定義ファイルが存在してません chname:" + chname + " posename:" + posename + " filename:" + filename);
			} else {
				var chinfo = result[chname];
				if (chinfo == void) {
					chlist.add(chname);
					chinfo = %[name:chname, map:%[], list:[], allDressNameList:[], allDressNameMap:%[]];
					result[chname] = chinfo;
				}
				var dressNames = [];
				var dressMap  = %[];
				var faceList  = [];
				var faceMap   = %[];
				var addMap    = %[];
				var fgList    = [];
				var fgMap     = %[];
				var fgAliasList = [];
				var fgAliasMap = %[];
				var fgNameList = [];
				var fgNameMap  = %[];
				{
					// ポーズ情報の読み出し
					var file = [];
					try {
						file.load(infofile);
					} catch (e) {
						dm("キャラクタ:" + name + "のポーズ:" + pose + "の情報ファイル:" + infofile + "の読み込みに失敗しました");
					}
					for (var i=0;i<file.count;i++) {
						var line = file[i].split(/\t/);
						if (line.count > 0 && line[0].charAt(0) != "#") {
							switch(line[0].toLowerCase()) {
							case "rename":
								// 名前置換処理
								if (line.count >= 3 && line[2] != "" && line[3] != "") {
									var name = line[2];
									var target = line[3];
									switch (line[1]) {
									case "dress":
										{
											var dress = dressMap[target];
											if (dress !== void) {
												dress.name = name;
												dressMap[name] = dress;
												delete dressMap[target];
											}
											for (var i=0;i<dressNames.count;i++) {
												if (dressNames[i] == target) {
													dressNames[i] = name;
												}
											}
										}
										break;
									case "diff":
										{
											var names = [];
											names.assign(dressMap);
											for (var i=0;i<names.count;i+=2) {
												var diffMap = names[i+1].diffMap;
												var diff = diffMap[target];
												if (diff !== void) {
													diff.name = name;
													diffMap[name] = diff;
													delete diffMap[target];
												}
											}
										}
										break;
									case "face":
										{
											var face = faceMap[target];
											if (face !== void) {
												face.name = name;
												faceMap[name] = face;
												delete faceMap[target];
											}
										}
										break;
									}
								}
								break;
							case "dress":
								{
									var dressName = line[1];
									var dress = dressMap[dressName];
									if (dress === void) {
										// 新規服装
										dress = %[name:dressName, baseList:[], diffList:[], diffMap:%[]];
										dressMap[dressName] = dress;
										dressNames.add(dressName);
									}
									switch (line[2].toLowerCase()) {
									case "base": // ベース画像追加
										dress.baseList.add(line[3]);
										break;
									case "diff":
										{
											var diffName = line[3];
											var diff = dress.diffMap[diffName];
											if (diff === void) {
												diff = %[name:diffName, list:[]];
												dress.diffList.add(diff);
												dress.diffMap[diffName] = diff;
											}
											diff.list.add(line[4]);
											if (line.count >= 6) {
												diff.facefolder = line[5];
											}
										}
										break;
									case "diffface":
										{
											var diffName = line[3];
											var diff = dress.diffMap[diffName];
											if (diff === void) {
												diff = %[name:diffName, list:[]];
												dress.diffList.add(diff);
												dress.diffMap[diffName] = diff;
											}
											diff.defaultFace = line[4];
										}
										break;
									}
								}
								break;
							case "face":
								{
									var faceName = line[1];
									var faceTarget;
									var l;
									if ((l = faceName.indexOf("#")) > 0) {
										faceTarget  = faceName.substr(l);
										faceName    = faceName.substr(0,l);
									} else if ((l = faceName.indexOf("@")) > 0) {
										faceTarget  = faceName.substr(l);
										faceName    = faceName.substr(0,l);
									}
									var face = faceMap[faceName];
									if (face === void) {
										// 新規表情
										face = %[name:faceName, baseList:[]];
										faceList.add(face);
										faceMap[faceName] = face;
									}
									switch (line[2].toLowerCase()) {
									case "base": // ベース画像追加
										{
											var baseName = line[3];
											var fdata = %[name:baseName];
											if (faceTarget !== void) {
												fdata.target = faceTarget;
											}
											face.baseList.add(fdata);
											if (face.eyebase === void) {
												face.eyebase = baseName + "・目";
											}
											if (face.lipbase === void) {
												face.lipbase = baseName + "・口";
											}
										}
										break;
									case "eyeimage": // 目画像直接指定
										face.eyeimage = line[3];
										break;
									case "lipimage": // 口画像直接指定
										face.lipimage = line[3];
										break;
									case "eye": // 目画像グループ差し替え
										face.eyebase = line[3];
										break;
									case "lip": // 口画像グループ差し替え
										face.lipbase = line[3];
										break;
									case "noeye":
										face.eyeimage = void;
										face.eyebase = void;
										break;
									case "nolip":
										face.lipimage = void;
										face.lipbase = void;
										break;
									}
								}
								break;
							case "facegroup":
								{
									var name = line[1];
									var fginfo = %[name:name,list:[]];
									fgList.add(fginfo);
									fgMap[name] = fginfo;
								}
								break;
							case "fgname":
								{
									var name = line[1];
									var fgno = -1;
									for (var i=0;i<fgList.count;i++) {
										var fgname = fgList[i].name;
										if (name.substring(0,fgname.length) == fgname) {
											fgno = i;
										}
									}
									if (fgno >= 0) {
										var fgName = fgNameMap[name];
										if (fgName === void) {
											fgName = %[name:name, fgno:fgno, eyes:false, lips:false, baseList:[]];
											fgNameList.add(fgName);
											fgNameMap[name] = fgName;
											fgList[fgno].list.add(fgName);
										}
										var layName = line.count > 2 ? line[2] : name; // レイヤ名
										var layCond = line.count > 3 ? line[3] : void; // 表示条件
										fgName.baseList.add([layName,layCond]);
										if (layCond !== void) {
											if (layCond.substr(0,3) == "eye") {
												fgName.eyes = true;
											} else if (layCond.substr(0,3) == "lip") {
												fgName.lips = true;
											}
										}
									} else {
										dm("fgname:" + name + ":該当facegroupがありません:");
									}
								}
								break;
							case "fgalias":
								{
									var name = line[1];
									var value = [];
									for (var j=2;j<line.count;j++) {
										value.add(line[j]);
									}
									var fgAlias = %[name:name, value:value];
									fgAliasList.add(fgAlias);
									fgAliasMap[name] = fgAlias;
								}
								break;
							case "add":
								{
									var addName = line[1];
									var add = addMap[addName];
									if (add === void) {
										// 新規表情
										add = %[name:addName];
										addMap[addName] = add;
									}
								}
								break;
							}
						}
					}
				}
				for (var i=0;i<dressNames.count;i++) {
					var dressName = dressNames[i];
					if (chinfo.allDressNameMap[dressName] === void) {
						chinfo.allDressNameMap[dressName] = true;
						chinfo.allDressNameList.add(dressName);
					}
				}
				// ポーズ名とファイル名の対応を保存
				var info = %[name:chname, pose:posename, filename:filename, xoffset:xoffset, yoffset:yoffset, emoRev:emoRev,
						 facezoom:facezoom, facexoff:facexoff, faceyoff:faceyoff,
						 dressMap:dressMap, faceList:faceList, faceMap:faceMap, addMap:addMap,
						 fgList:fgList, fgMap:fgMap, fgAliasList:fgAliasList, fgAliasMap:fgAliasMap, fgNameList:fgNameList, fgNameMap:fgNameMap];
				chinfo.list.add(info);
				chinfo.map[posename] = info;
			}
		}
	}
};

/**
 * 立ち絵定義レベル情報ファイル読み出しパーサ
 */
class ExStandLevelParser extends CSVParser 
{
	var result;

	/**
	 * コンストラクタ
	 */
	function ExStandLevelParser() {
		super.CSVParser(...);
		result = %[];
	}

    /**
     * 行毎に呼び出される
     * @param columns カラムデータ(Array)
     * @param lineNo 論理行番号(1〜)
     */
	function doLine(columns, lineNo) {
		if (columns.count > 0 && columns[0].length > 0 && columns[0].charAt(0) != "#") {
			var chname   = columns[0];
			var posename = columns[1];
			var ch = result[chname];
			if (ch === void) {
				ch = %[];
				result[chname] = ch;
			}
			var levels   = [];
			for (var i=2;i<columns.length;i+=2) {
				levels.add(%[x:+columns[i],y:+columns[i+1]]);
			}
			ch[posename] = levels;
		}
	}
};

/**
 * 立ち絵定義アニメ情報ファイル読み出しパーサ
 */
class ExStandAnimParser extends CSVParser 
{
	var result;

	/**
	 * コンストラクタ
	 */
	function ExStandAnimParser() {
		super.CSVParser(...);
		result = %[];
	}

    /**
     * 行毎に呼び出される
     * @param columns カラムデータ(Array)
     * @param lineNo 論理行番号(1〜)
     */
	function doLine(columns, lineNo) {
		if (columns.count > 1 && columns[0].length > 0 && columns[0].charAt(0) != "#") {
			// キャラ情報
			var chname   = columns[0];
			var map = result[chname];
			if (map === void) {
				map = %[];
				result[chname] = map;
			}
			// アニメ情報
			var aname = columns[1];
			var anim = map[aname];
			if (anim === void) {
				anim = [];
				map[aname] = anim;
			}
			// データを登録
			var line = [];
			for (var i=2;i<columns.length;i++) {
				line.add(columns[i]);
			}
			anim.add(line);
		}
	}
};
	// 立ち絵情報
	var parser = new ExStandInfoParser();
	parser.parseStorage("charinit.csv");
	allStandInfoMap  = parser.result;
	allStandInfoList = parser.chlist;

	invalidate parser;

	// レベル情報
	parser = new ExStandLevelParser();
	parser.parseStorage("charlevel.csv");
	allStandLevelMap = parser.result;
	invalidate parser;

	// アニメ情報
	parser = new ExStandAnimParser();
	parser.parseStorage("charanim.csv");
	allStandAnimMap = parser.result;
	invalidate parser;
}

var dumplist;
var dumpdone;
var dumpindent;
var globaladdr;

function getAddr(obj)
{
	return ((string)obj).substring(8,10);
}

function getBase(obj)
{
	return ((string)obj).substring(19,10);
}

function _dump(name, value)
{
	if (typeof value == "Object") {
		if (value == null) {
			return;
		}
		var valuename = (string)value;
		if (value === global || (value !== sf &&
								 value !== f &&
								 value !== kag &&
								 value !== dumpdone &&
								 value !== dumplist &&
								 dumpdone[valuename] === void &&
								 getAddr(value) == getBase(value))) {
			var disp = "";
			for (var i=0;i<dumpindent;i++) {
				disp += " ";
			}
			dumplist.add(disp + name + ":" + value);
			dumpdone[valuename] = true;
			if (value instanceof "Array") {
				dumpindent++;
				for (var i=0;i<value.count;i++) {
					_dump(name + "[" + i + "]", value[i]);
				}
				dumpindent--;
			} else {
				var names = [];
				names.assign(value);
				for (var i=0;i<names.count;i+=2) {
					dumpindent++;
					try {
						var v = value[names[i]];
						_dump(names[i], v);
					} catch (e) {
					}
					dumpindent--;
				}
			}
		}
	} else {
		var disp = "";
		for (var i=0;i<dumpindent;i++) {
			disp += " ";
		}
		dumplist.add(disp + name + ":" + value);
	}
}

var dumpcount = 0;
function dump() {
	if (typeof global.Array.save2 == "undefined") {
		Plugins.link("savestruct.dll");
	}
	dumplist = [];
	dumpdone = %[];
	globaladdr = getBase(global);
	_dump("global", global);
	dumplist.save2("vardump" + dumpcount++);
}

// テスト用
var testcount = 0;
function saveStandInfo()
{
	(Dictionary.saveStruct incontextof allStandInfoMap)("teststandinfo" + testcount);
	(Dictionary.saveStruct incontextof allStandLevelMap)("teststandlevel" + testcount);
	(Dictionary.saveStruct incontextof allStandAnimMap)("teststandanim" + testcount);
	testcount++;
}

function getFaceNameList(faceName)
{
	if (faceName !== void && faceName.indexOf(":") >= 0) {
		return faceName.split(":");
	} else {
		return [];
	}
}

// 有効な表情名の判定
function isValidFace(info, faceName)
{
	return faceName.indexOf(":") >= 0 || info.faceMap[faceName] !== void || info.fgAliasMap[faceName] !== void || info.fgNameMap[faceName] !== void;
}

// 有効な表情名に変換
function getFixedFaceName(info, currentFaceName, faceName)
{
	var n;
	var newface;
	if (info.faceMap[faceName] !== void) {
		// 通常表情
		return faceName;
	} else if ((n = info.fgNameMap[faceName]) !== void) {
		// 表情グループ
		newface = getFaceNameList(currentFaceName);
		newface[n.fgno] = faceName;
	} else if ((n = info.fgAliasMap[faceName]) !== void) {
		// 表情グループエイリアス指定
		newface = getFaceNameList(currentFaceName);
		var value = n.value;
		for (var i=0;i<value.count;i++) {
			var name = value[i];
			if ((n = info.fgNameMap[name]) !== void) {
				newface[n.fgno] = name;
			}
		}
	}
	if (newface !== void) {
		faceName = newface[0];
		for (var i=1;i<newface.count;i++) {
			faceName += ":";
			faceName += newface[i];
		}
	}
	return faceName;
}

/**
 * 立ち絵に対する想定レベルを返す
 */
function checkStandLayerLevel(level, levelMax, standInfo, levels, searchSmallLevel=true)
{
	var imageLevel = void;
	for (var l=(int)level;l<levelMax;l++) {
		var levelInfo;
		var levelName;
		if (levels !== void && (levelInfo = levels[l]) !== void && (levelName = levelInfo.name) !== void) {
			var file = standInfo.filename + "_" + levelName + ".txt";
			if (Storages.isExistentStorage(file)) {
				imageLevel = l;
				break;
			}
		}
		var file = standInfo.filename + "_" + l + ".txt";
		if (Storages.isExistentStorage(file)) {
			imageLevel = l;
			break;
		}
	}
	if (searchSmallLevel && imageLevel === void) {
		for (var l=level;l>=0;l--) {
			var levelInfo;
			var levelName;
			if (levels !== void && (levelInfo = levels[l]) !== void && (levelName = levelInfo.name) !== void) {
				var file = standInfo.filename + "_" + (levelInfo.name) + ".txt";
				if (Storages.isExistentStorage(file)) {
					imageLevel = l;
					break;
				}
			}
			var file = standInfo.filename + "_" + l + ".txt";
			if (Storages.isExistentStorage(file)) {
				imageLevel = l;
				break;
			}
		}
	}
	return imageLevel;
}

/**
 * 立ち絵画像情報管理
 */
class StandPSDInfo extends PSDInfo {

	var info;
	var imageLevel; // 実際に読み込まれてるレベル(nullなら100%画像)
	
	function StandPSDInfo(window, standinfo, imageLevel, levels) {
		super.PSDInfo(window);
		this.info = standinfo;
		setIgnoreLayer("背景", "原点", "領域");
		this.imageLevel = imageLevel;
		var filename;
		if (imageLevel === void) {
			filename = info.filename + ".txt";
		} else {
			var levelInfo;
			var levelName;
			if (levels !== void && (levelInfo = levels[imageLevel]) !== void && (levelName = levelInfo.name) !== void) {
				filename = info.filename + "_" + levelName + ".txt";
			} else {
				filename = info.filename + "_" + imageLevel + ".txt";
			}
		}
		try {
			loadImages(filename, true);
		} catch(e) {
			//throw new Exception("キャラクタ:" + name + "のポーズ:" + poseName + "の画像ファイル:" + standinfo.filename + "の読み込みに失敗しました");
			var msg = "キャラクタ[" + info.name + "] の ポーズ[" + info.pose + "] の画像ファイル [" + filename + "] の読み込みに失敗しました:" + e.message;
			dm(msg);
		}
	}

	/**
	 * 表情展開の実行
	 */
	function extractFace(face) {
		with (face) {
			.defaultEye = "";
			.defaultLip = "";

			//dm("表情:" + .name + " 目ベース:" + .eyebase + " 口ベース:" + .lipbase);
			
			// 目のチェック
			for (var i=0;i<groups.count;i++) {
				var group = groups[i];
				if (.eyebase !== void && group.name == .eyebase) {
					if (group.layers.count > 0) {
						.defaultEye = .eyebase + "/" + group.layers[0].name;
						if (group.layerMap["閉じ目"] !== void &&
							(group.layerMap["半閉じ目"] !== void || group.layerMap["半開き目"] !== void) &&
							group.layerMap["開き目"] !== void
							) {
							.eyes = [];
							.eyes[0] = .eyebase + "/閉じ目";
							if (group.layerMap["半閉じ目"] !== void) {
								.eyes[1] = .eyebase + "/半閉じ目";
							} else if (group.layerMap["半開き目"] !== void) {
								.eyes[1] = .eyebase + "/半開き目";
							}
							.eyes[2] = .eyebase + "/開き目";
						}
						//dm("デフォルト目:" + .defaultEye + (.eyes !== void ? " 目ぱちあり":""));
					}
					break;
				}
			}
			// 口のチェック
			for (var i=0;i<groups.count;i++) {
				var group = groups[i];
				if (.lipbase !== void && group.name == .lipbase) {
					if (group.layers.count > 0) {
						.defaultLip = .lipbase + "/" + group.layers[0].name;
						if (group.layerMap["閉じ口"] !== void &&
							(group.layerMap["半閉じ口"] !== void || group.layerMap["半開き口"] !== void) &&
							group.layerMap["開き口"] !== void
							) {
							.lips = [];
							.lips[0] = .lipbase + "/閉じ口";
							if (group.layerMap["半閉じ口"] !== void) {
								.lips[1] = .lipbase + "/半閉じ口";
							} else if (group.layerMap["半開き口"] !== void) {
								.lips[1] = .lipbase + "/半開き口";
							}
							.lips[2] = .lipbase + "/開き口";
						}
						//dm("デフォルト口:" + .defaultLip + (.lips !== void ? " 口ぱくあり":""));
					}
					break;
				}
			}
		}
	}

	// 表情情報を取得
	function getFaceInfo(faceName) {
		var faceInfo = info.faceMap[faceName];
		if (faceInfo !== void && faceInfo.defaultEye === void) {
			extractFace(faceInfo);
		}
		return faceInfo;
	}
};

/**
 * 立ち絵用画像レイヤ
 * 差分の表示状態 ON/OFF をサポートします
 */
class StandLayer extends PSDLayer {

	var poseName;
	var level;
	
	var currentDressName; //< 現在のドレス名
	var currentDiffName;  //< 現在の差分名
	var currentFaceName;  //< 現在の表情名
	var currentLipLevel;   //< 現在の口ぱくレベル
	var currentEyeLevel;   //< 現在の目パターンレベル

	var diffNames; //< 表示中差分レイヤ名情報
	var faceNames; //< 表示中表情レイヤ名情報
	var addNames;  //< 追加特殊要素レイヤ名情報
	var addFaceNames; //< 特殊追加要素レイヤ（表情用)
	
	/**
	 * コンストラクタ
	 * @param parent 親レイヤ
	 * @param psdinfo PSD情報
	 */
	function StandLayer(parent, psdinfo, poseName, level) {
		super.PSDLayer(parent.window, parent, psdinfo);
		diffNames = [];
		faceNames = [];
		addNames = [];
		addFaceNames = [];
		this.poseName = poseName;
		this.level    = level;
	}

	function clone(instance) {
		if (instance == void) {
			instance = new global.StandLayer(parent, psdinfo, poseName, level);
		}
		super.clone(instance);
		instance.currentDressName = currentDressName;
		instance.currentDiffName  = currentDiffName;
		instance.currentFaceName  = currentFaceName;
		instance.currentLipLevel  = currentLipLevel;
		instance.currentEyeLevel  = currentEyeLevel;
		(Array.assign incontextof instance.diffNames)(diffNames);
		(Array.assign incontextof instance.faceNames)(faceNames);
		(Array.assign incontextof instance.addNames)(addNames);
		(Array.assign incontextof instance.addFaceNames)(addFaceNames);
		return instance;
	}

	function finalize() {
		diffNames.clear();
		invalidate diffNames;
		faceNames.clear();
		invalidate faceNames;
		addNames.clear();
		invalidate addNames;
		addFaceNames.clear();
		invalidate addFaceNames;
		super.finalize();
	}

	/**
	 * 全レイヤを隠す
	 */
	function hideAll() {
		// 全レイヤは表示OFF
		for (var i=0;i<layers.count;i++) {
			var layer = layers[i];
			setVisibleInfo(layer, false);
		}
		// 全グループの表示を有効化
		for (var i=0;i<groups.count;i++) {
			var group = groups[i];
			setVisibleInfo(group, true);
		}
	}
	
	/**
	 * 服装指定
	 */
	function setDress(dressName) {
		if (dressName != currentDressName) {
			//dm("ドレス変更!");
			var dressInfo = info.dressMap[dressName];
			if (dressInfo === void) {
				// 該当服装が無いので例外
				throw new Exception("該当する服装がありません pose:" + info.pose + " dress:" + dressName);
			}
			// いったん全レイヤを消去
			hideAll();
			// ベースレイヤを表示
			var base = dressInfo.baseList;
			for (var i=0;i<base.count;i++) {
				setVisible(base[i], true);
			}
			currentDressName = dressName;

			currentDiffName = void;
			diffNames.clear();
			currentFaceName = void;
			faceNames.clear();
			addNames.clear();
			addFaceNames.clear();
		}
	}
	
	/**
	 * 差分指定
	 */
	function setDiff(diffName) {
		if (diffName != currentDiffName) {
			//dm("差分変更!");
			var dressInfo = info.dressMap[currentDressName];
			if (dressInfo === void) {
				// 該当服装が無いので例外
				throw new Exception("該当する服装がありません pose:" + info.pose + " dress:" + currentDressName);
			}
			// 以前の差分の消去
			for (var i=0;i<diffNames.count;i++) {
				setVisible(diffNames[i], false);
			}
			diffNames.clear();
			// 新規差分情報
			if (diffName !== void) {
				var diffInfo = dressInfo.diffMap[diffName];
				if (diffInfo === void) {
					// 該当差分が無いので例外
					throw new Exception("該当する差分がありません pose:" + info.pose + " dress:" + currentDressName + " diff:" + diffName);
				}
				// 新規差分の表示
				var list = diffInfo.list;
				for (var i=0;i<list.count;i++) {
					setVisible(list[i], true);
					diffNames.add(list[i]);
				}
				// 差分をかえたときは表情も初期化
				//if (diffInfo.facefolder !== void) {
				currentFaceName = void;
				//}
			}
			currentDiffName = diffName;
		}
	}

	/**
	 * 差分指定
	 */
	function setAdd(name, clear=false) {
		if (name == "" || clear) {
			// 以前の差分の消去
			for (var i=0;i<addNames.count;i++) {
				setVisible(addNames[i], false);
			}
			addNames.clear();
		}
		if (name != "") {
			setVisible(name, true);
			addNames.add(name);
		}
	}

	/**
	 * 差分指定
	 */
	function setAddFace(name, clear=false) {
		if (name == "" || clear) {
			// 以前の差分の消去
			for (var i=0;i<addFaceNames.count;i++) {
				setVisible(addFaceNames[i], false);
			}
			addFaceNames.clear();
		}
		if (name != "") {
			setVisible(name, true);
			addFaceNames.add(name);
		}
	}
	
	// ---------------------------------------------------
	
	var lipLevel;
	var eyeLevel;

	// 口のレベル指定
	function setLipLevel(lipLevel) {
		this.lipLevel = lipLevel;
	}

	// 目のレベル指定
	function setEyeLevel(eyeLevel) {
		this.eyeLevel = eyeLevel;
	}

	// フォルダ指定がある場合はそちらを優先処理する仕組み
	function setFaceVisible(name, v) {
		var dressInfo = info.dressMap[currentDressName];
		var diffInfo = dressInfo.diffMap[currentDiffName];
		//dm("フォルダ指定:" + diffInfo.facefolder);
		if (diffInfo !== void && diffInfo.facefolder !== void) {
			var n = diffInfo.facefolder + "/" + name;
			//dm("フル名称:" + n);
			if (layerFullnames[n] !== void) {
				//dm("フル名指定成功");
				setVisible(n, v);
				faceNames.add(n);
				return;
			}
		}
		setVisible(name, v);
		faceNames.add(name);
	}

	function foreMatch(target, name) {
		var not = false;
		var ret;
		if (target.charAt(0) == "!") {
			not = true;
			target = target.substr(1);
		}
		var l = target.length-1;
		if (target.charAt(l) == "*") {
			//末尾に*なら前方一致
			ret =  target.substr(0,l) == name.substr(0,l);
		} else {
			//完全一致
			ret =  target == name;
		}
		return not ? !ret : ret;
	}
	

	// 表情指定
	function setFace(faceName) {
		if (faceName != currentFaceName || lipLevel !== currentLipLevel || eyeLevel !== currentEyeLevel) {
			//dm("表情変更!");
			// 以前の表情の消去
			for (var i=0;i<faceNames.count;i++) {
				setVisible(faceNames[i], false);
			}
			faceNames.clear();
			if (faceName !== void) {
				var faceInfo = getFaceInfo(faceName);
				if (faceInfo !== void) {
					// 新規表情の表示
					var base = faceInfo.baseList;
					for (var i=0;i<base.count;i++) {
						var n = base[i].name;
						var t = base[i].target;
						//dm("target:" + t);
						if (t !== void) {
							if (t.charAt(0) == "#") { // 差分限定
								var a = t.indexOf("@"); // 服装限定指定
								if (a >= 0) {
									var dress = t.substring(a+1);
									var diff  = t.substring(1,a-1);
									if (foreMatch(dress, currentDressName) &&
										foreMatch(diff, currentDiffName)) {
										setFaceVisible(n, true);
									}
								} else {
									var diff  = t.substring(1);
									if (foreMatch(diff, currentDiffName)) {
										setFaceVisible(n, true);
									}
								}
							} else if (t.charAt(0) == "@") {
								var dress = t.substring(1);
								if (foreMatch(dress, currentDressName)) {
									setFaceVisible(n, true);
								}
							}
						} else {
							setFaceVisible(n, true);
						}
					}
					if (faceInfo.lipimage !== void) {
						setFaceVisible(faceInfo.lipimage);
					} else if (faceInfo.lipbase !== void) {
						// 口ぱく用特殊処理
						var lipname;
						if (lipLevel === void || faceInfo.lips === void) {
							lipname = faceInfo.defaultLip;
						} else {
							lipname = faceInfo.lips[lipLevel];
						}
						if (lipname != "") {
							setFaceVisible(lipname, true);
						}
					}
					
					if (faceInfo.eyeimage !== void) {
						setFaceVisible(faceInfo.eyeimage);
					} else if (faceInfo.eyebase !== void) {
						// 目ぱち用特殊処理
						var eyename;
						if (eyeLevel === void || faceInfo.eyes === void) {
							eyename = faceInfo.defaultEye;
						} else {
							eyename = faceInfo.eyes[eyeLevel];
						}
						if (eyename != "") {
							setFaceVisible(eyename, true);
						}
					}
				} else if (faceName.indexOf(":") >= 0) {
					// 差分指定用
					var faces = faceName.split(":");
					for (var i=0;i<faces.count;i++) {
						if (faces[i].length > 0) {
							var fgName = info.fgNameMap[faces[i]];
							if (fgName !== void) {
								var list = fgName.baseList;
								for (var j=0;j<list.count;j++) {
									var info = list[j];
									var name = info[0];
									var cond = info[1];
									// 条件判定
									var l = lipLevel === void ? 0 : lipLevel; // 口は閉じるのがデフォルト
									var e = eyeLevel === void ? 2 : eyeLevel; // 目は開くのがデフォルト
									//dm("表示条件:lipsLevel:" + l  + " eyelevel:" + e);
									if (cond === void || cond == "" ||
										(cond.substr(0,3) == "eye" && +cond.substr(3) == e) ||
										(cond.substr(0,3) == "lip" && +cond.substr(3) == l)) {
										setFaceVisible(name, true);
									}
								}
							} else {
								setFaceVisible(faces[i], true);
							}
						}
					}
				} else {
					// 該当表情が無いので例外
					throw new Exception("該当する表情がありません pose:" + info.pose + " face:" + faceName);
				}
			}
			
			currentFaceName = faceName;
			currentLipLevel = lipLevel;
			currentEyeLevel = eyeLevel;
		}
	}
	
};

/**
 * キャラクタ拡張
 */
class KAGEnvCharacterEx extends KAGEnvCharacter {

	// キャラ立ち絵情報
	var chstandinfo;
	var chstandlevel;
	var chstandanim;

	// 立ち絵レイヤのキャッシュ
	var standlayerList = []; // 立ち絵レイヤ情報の保持用
	var standlayerMap = %[]; // ポーズ名との対応マップ

	// 現在選択可能な服装の一覧
	var currentPoseNameMap  = %[];
	var currentPoseNameList = [];
	// 現在選択可能な差分の一覧
	var currentDiffNameMap  = %[];
	var currentDiffNameList = [];
	// 現在選択可能な表情の一覧
	var currentFaceNameMap  = %[];
	var currentFaceNameList = [];

	// 参照中立ち絵レイヤ画像
	var standlayer;
	var facelayer;
	
	/**
	 * コンストラクタ
	 */
	function KAGEnvCharacterEx(env, name, initName, init) {

		super.KAGEnvCharacter(...);
		
		// 情報初期化
		chstandinfo  = allStandInfoMap[standName];
		chstandlevel = allStandLevelMap[standName];
		chstandanim  = allStandAnimMap[standName];

		// 初期服装指定（デフォルト）
		if (chstandinfo !== void && chstandinfo.allDressNameList.count > 0) {
			_setDress(chstandinfo.allDressNameList[0]);
		}

		// フリップ用の値の初期化
		eyeflipTime = global.eyeFlipTime;
		lipflipTime = global.lipFlipTime;
	}

	function clearListMap(list,map) {
		(Dictionary.clear incontextof map)(); 
		for (var i=list.count-1;i>=0;i--) {
			if (typeof list[i] == "Object") {
				invalidate list[i];
			}
			list.erase(i);
		}
	}

	function invalidateListMap(list,map) {
		clearListMap(list, map);
		invalidate list;
		invalidate map;
	}
	
	/**
	 * ファイナライザ
	 */
	function finalize() {
		stopAnim();
		System.removeContinuousHandler(updateHandler);
		invalidate standlayer if standlayer !== void;
		invalidate facelayer if facelayer !== void;
		super.finalize();
		invalidateListMap(standlayerList, standlayerMap);
		invalidateListMap(currentPoseNameList, currentPoseNameMap);
		invalidateListMap(currentDiffNameList, currentDiffNameMap);
		invalidateListMap(currentFaceNameList, currentFaceNameMap);
	}
	
	/**
	 * 指定した名前に該当する基礎立ち絵情報を取得
	 * @param pose ポーズ名または番号
	 * @return 立ち絵情報
	 */
	function getStandInfoCount() {
		return chstandinfo === void ? 0 : chstandinfo.list.count;
	}
	
	/**
	 * 指定した名前に該当する基礎立ち絵情報を取得
	 * @param pose ポーズ名または番号
	 * @return 立ち絵情報
	 */
	function getStandInfo(pose) {

		if (chstandinfo === void) {
			return void;
		}

		var standinfo;
		if (typeof pose == "Integer") {
			standinfo = chstandinfo.list[pose];
		} else {
			// ポーズ情報
			standinfo = chstandinfo.map[pose];
			if (standinfo === void) {
				// 最初のものがデフォルト
				standinfo = chstandinfo.list[0];
			}
		}
		if (standinfo === void) {
			throw new Exception("キャラクタ:" + name + "のポーズ:" + pose + "の情報がありません");
		}
		return standinfo;
	}

	/**
	 * 指定した名前に該当する立ち絵表示情報を返す
	 * @param poseName ポーズ名
	 * @param level レベル
	 * @return 立ち絵表示情報
	 */
	function getStandLayerInfo(poseName, level) {

		// 該当ポーズの立ち絵リスト
		var standlayers = standlayerMap[poseName];
		if (standlayers === void) {
			standlayers = [];
			standlayerMap[poseName] = standlayers;
			standlayerList.add(standlayers);
		}

		// 立ち絵情報
		var standInfo = getStandInfo(poseName);
		// 実画像のレベルを取得
		var l = env.camerazoom > 100 && level < env.levels.count-1 ? level + 1 : level;
		var imageLevel = checkStandLayerLevel(l, env.levels.count, standInfo, env.levels, env.searchSmallLevel);
		//dm("立ち絵レイヤ取得 name:%s cz:%d level:%d l:%d imageLevel:%d".sprintf(name, env.camerazoom, level, l, imageLevel));
		
		var psdinfo;
		var count = standlayers.count;
		for (var i=0;i<count;i++) {
			var info = standlayers[i];
			if (info.imageLevel === imageLevel) { // 既にロード済み
				psdinfo = info;
				if (i != 0) {
					// 先頭に移動させる
					standlayers.erase(i); standlayers.unshift(psdinfo);
				}
				break;
			}
		}
		if (psdinfo === void) {
			// 見つからない場合は新規に作成
			psdinfo = new StandPSDInfo(kag, standInfo, imageLevel, env.levels);
			while (standlayers.count > 3) { // キャッシュは4つまで
				standlayers.pop();
			}
			standlayers.unshift(psdinfo);
		}

		return psdinfo;
	}
	
	/**
	 * 指定した名前に該当する基礎立ち絵レイヤを生成
	 * @param poseName ポーズ名
	 * @param level レベル
	 * @return 立ち絵レイヤ
	 */
	function createStandLayer(poseName, level) {
		var psdinfo = getStandLayerInfo(poseName, level);
		var standlayer = new StandLayer(kag.temporaryLayer, psdinfo, poseName, level);
		standlayer.name = name + "_" + poseName;
		return standlayer;
	}

	function clearStandLayers() {
		// キャッシュを全削除する
		(Dictionary.clear incontextof standlayerMap)(); 
		for (var i=standlayerList.count-1;i>=0;i--) {
			var standlayers = standlayerList[i];
			if (standlayers) {
				for (var j=standlayers.count-1;j>=0;j--) {
					invalidate standlayers[j] if (standlayers[j]);
				}
				invalidate standlayers;
			}
		}
		standlayerList.clear();
	}

	// -----------------------------------------------------------------
	// 各種ロジックの差し替え

	// 保持変数
	var diff;  //< 差分情報
	var addimage; //< 特殊追加画像
	var addface;  //< 表情用特殊追加画像
	
    /**
     * セーブ処理
     */
	function onStore(f) {
		super.onStore(f);
		f.diff = diff;
		f.addimage = addimage;
		f.addface  = addface;
		f.animCmd = animCmd;
		f.eyestate = eyestate;
		f.lipstate = lipstate;
		f.eyeflip = eyeflip;
		f.eyeflipTime = eyeflipTime;
		f.lipflip = lipflip;
		f.lipflipTime = lipflipTime;
    }

    /**
     * ロード処理
     */
	function onRestore(f) {
		diff  = f.diff;
		addimage = f.addimage;
		addface  = f.addface;
		super.onRestore(f);
		if (f.animCmd !== void) {
			doAnimCommand(f.animCmd, null, null);
		}
		if (isShow()) {
			eyeflip = f.eyeflip;
			eyeflipTime = f.eyeflipTime;
			lipflip = f.lipflip;
			lipflipTime = f.lipflipTime;
			setEyeState(f.eyestate);
			setLipState(f.lipstate); 
		}
		if (dress !== void) {
			_setDress(dress);
		}
    }

	// ----------------------------------------------------
	// 指定コマンド
	// ----------------------------------------------------

	/**
	 * 差分と表情のリセット処理
	 */
	function checkDiffFace() {
		var info = getStandInfo(pose);
		var dressInfo = info.dressMap[dress];
		if (dressInfo === void) {
			throw new Exception("ポーズに該当する服装が存在しません pose:" + pose + " dress:" + dress);
		}
		// 差分の再設定。未設定または同じものが無ければ該当する最初のものにする
		if (diff === void || dressInfo.diffMap[diff] === void) {
			if (dressInfo.diffList.count > 0) {
				diff = dressInfo.diffList[0].name;
			} else {
				diff = void;
				dm("差分が全く存在しません dress:" + dress);
			}
		}
		// 表情の再設定。未設定または同じものが無ければ該当する最初のものにする
		if (face === void || !isValidFace(info, face)) {
			if (info.faceList.count > 0) {
				face = info.faceList[0].name;
			} else if (info.fgList.count > 0) {
				var list = info.fgList;
				face = "";
				for (var i=0;i<list.count;i++) {
					if (i>0) {
						face += ":";
					}
					if (list[i].list.count > 0) {
						face += list[i].list[0].name;
					}
				}
			} else {
				face = void;
				dm("表情が全く存在しません dress:" + dress);
			}
		}
	}

	function setEyeLipState() {
		var psdinfo = getStandLayerInfo(pose, level);
		if (psdinfo !== void) {
			var faceInfo = psdinfo.getFaceInfo(face);
			if (faceInfo !== void) {
				// パターンが存在すれば目ぱち・口ぱくともに有効
				setEyeState(faceInfo.eyes !== void ? 6 : 0);
				setLipState(faceInfo.lips !== void ? 6 : 0); 
			} else if (face !== void) {
				var eyes = false;
				var lips = false;
				var faces = face.split(":");
				for (var i=0;i<faces.count;i++) {
					if (faces[i].length > 0) {
						var fgName = psdinfo.info.fgNameMap[faces[i]];
						if (fgName !== void) {
							if (fgName.eyes) {
								eyes = true;
							}
							if (fgName.lips) {
								lips = true;
							}
						}
					}
				}
				// パターンが存在すれば目ぱち・口ぱくともに有効
				//dm("eyes:" + eyes +  " lips:" + lips);
				setEyeState(eyes ? 6 : 0);
				setLipState(lips ? 6 : 0); 
			}
		}
	}
	
	function _setDress(dressName) {

		dress = dressName;
		
		// 現在選択可能なポーズのリスト
		clearListMap(currentPoseNameList, currentPoseNameMap);
		clearListMap(currentDiffNameList, currentDiffNameMap);
		clearListMap(currentFaceNameList, currentFaceNameMap);
		
		var count = getStandInfoCount();
		for (var i=0;i<count;i++) {
			var info = getStandInfo(i);
			var dressInfo = info.dressMap[dress];
			if (dressInfo !== void) {
				// ポーズ一覧
				currentPoseNameMap[info.pose] = true;
				currentPoseNameList.add(info.pose);
				// 差分
				var difflist = dressInfo.diffList;
				for (var j=0;j<difflist.count;j++) {
					var name = difflist[j].name;
					if (currentDiffNameMap[name] === void) {
						currentDiffNameMap[name] = info.pose;
						currentDiffNameList.add(name);
					}
				}
				// 表情
				var facelist = info.faceList;
				for (var j=0;j<facelist.count;j++) {
					var name = facelist[j].name;
					if (currentFaceNameMap[name] === void) {
						currentFaceNameMap[name] = info.pose;
						currentFaceNameList.add(name);
					}
				}
				// 表情グループ指定名
				facelist = info.fgNameList;
				for (var j=0;j<facelist.count;j++) {
					var name = facelist[j].name;
					if (currentFaceNameMap[name] === void) {
						currentFaceNameMap[name] = info.pose;
						currentFaceNameList.add(name);
					}
				}
				// 表情グループエイリアス名
				facelist = info.fgAliasList;
				for (var j=0;j<facelist.count;j++) {
					var name = facelist[j].name;
					if (currentFaceNameMap[name] === void) {
						currentFaceNameMap[name] = info.pose;
						currentFaceNameList.add(name);
					}
				}
			}
		}
			
		// ポーズの再設定。未設定または同じものが無ければ該当する最初のものにする
		if (pose === void || getStandInfo(pose).dressMap[dress] === void) {
			pose = currentPoseNameList[0];
		}

		checkDiffFace();
	}
	
    /**
     * 服装の設定
     */
    function setDress(dressName, elm) {

		if (dressName != dress || isClear()) {
			// 服装変更時はエモーション消去
			if (elm.emotion === void) {
				hideEmotion();
			}
			initFile(elm);
			disp = SHOW;
			redraw = true;
			setAutoTrans([init.dressTrans, init.charTrans, env.envinfo.dressTrans, env.envinfo.charTrans], elm);

			// 表情表示取得
			setRedrawFace(elm);

			if (chstandinfo !== void && chstandinfo.allDressNameMap[dressName] === void) {
				exStandError("指定された服装が存在しません dress:" + dressName);
				return;
			}

			_setDress(dressName);		
			setEyeLipState();
		}
		
		image = void;
    }

    /**
	 * ポーズの設定
	 */
    function setPose(poseName, elm) {

		if (poseName != pose || isClear()) {
			// ポーズ変更時はエモーション消去
			if (elm.emotion === void) {
				hideEmotion();
			}
			initFile(elm);
			disp = SHOW;
			redraw = true;
			setAutoTrans([init.poseTrans, init.charTrans, env.envinfo.poseTrans, env.envinfo.charTrans], elm);

			// 表情表示取得
			setRedrawFace(elm);

			// 該当ドレスが無い場合は例外
			if (currentPoseNameMap[poseName] === void) {
				exStandError("服装に該当するポーズが存在しません pose:" + poseName + " dress:" + dress);
				return;
			}

			pose = poseName;
			checkDiffFace();
			setEyeLipState();

			addimage = void;
			addface = void;
		}

		image = void;
    }

    /**
	 * 差分の設定
	 */
	function setDiff(diffName, elm) {

		if (diffName != diff || isClear()) {
			initFile(elm);
			disp = SHOW;
			redraw = true;
			setAutoTrans([init.diffTrans, init.charTrans, env.envinfo.diffTrans, env.envinfo.charTrans], elm);

			// 表情表示取得
			setRedrawFace(elm);
			
			// 該当ドレスが無い場合はエラー
			if (currentDiffNameMap[diffName] === void) {
				exStandError("服装に該当する差分が存在しません diffName:" + diffName);
				return;
			}
			
			// 該当差分が無い場合は該当差分があるポーズに切り替える
			var dressInfo = getStandInfo(pose).dressMap[dress];
			if (dressInfo === void) {
				throw new Exception("ポーズに該当する服装が存在しません pose:" + pose + " dress:" + dress);
			}
			if (dressInfo.diffMap[diffName] === void) {
				pose = currentDiffNameMap[diffName];
			}

			// デフォルト表情指定
//			var dressInfo = getStandInfo(pose).dressMap[dress];
//			var diffInfo = dressInfo.diffMap[diffName];
//			if (diffInfo.defaultFace !== void) {
//				var faceName = diffInfo.defaultFace;
//				//dm("デフォルト表情指定:" + faceName);
//				if (getStandInfo(pose).faceMap[faceName] === void) {
//					exStandError("差分に指定されたデフォルト表情が存在しません faceName:" + faceName);
//				} else {
//					face = faceName;
//				}
//			}

			diff = diffName;
			checkDiffFace();
			setEyeLipState();
			
			addimage = void;
			addface = void;
		}
		
		image = void;
		// ypos を戻す
		ypos = 0;
    }

	/**
	 * 表情の設定
	 */
	function setFace(faceName, elm) {

		if (faceName != face || isClear()) {
			if (isClear()) {
				initFile(elm);
			}
			disp = SHOW;
			redraw = true;
			setAutoTrans([init.faceTrans, init.charTrans, env.envinfo.faceTrans, env.envinfo.charTrans], elm);

			// 表情表示取得
			setRedrawFace(elm);

			if (currentFaceNameMap[faceName] === void) {
				exStandError("服装に該当する表情が存在しません faceName:" + faceName);
				return;
			}
			// 現在のポーズに該当表情が無い場合は該当表情があるポーズに切り替える
			if (!isValidFace(getStandInfo(pose), faceName)) {
				pose = currentFaceNameMap[faceName];
			}
			
			face = getFixedFaceName(getStandInfo(pose), face, faceName);
			//dm("正規化済表情指定:" + face);
			checkDiffFace();
			//dm("調整済み表情指定:" + face);

			setEyeLipState();
			addface = void;
		}

		image = void;
    }

	function setAdd(param, elm) {
		if (addimage != param || isClear()) {
			//dm("add更新:" + param);
			disp = SHOW;
			redraw = true;
			addimage = param;
			// 表情表示取得
			setRedrawFace(elm);
		}
	}

	function setAddFace(param, elm) {
		if (addface != param || isClear()) {
			//dm("add更新:" + param);
			disp = SHOW;
			redraw = true;
			addface = param;
			// 表情表示取得
			setRedrawFace(elm);
		}
	}

	
	// ----------------------------------------------------
	// コマンド処理用
	// ----------------------------------------------------

    /**
	 * 服装指定処理用
     */
	function doDressCommand(cmd, param, elm) {

		if (cmd == "dress") {
			setDress(param, elm);
			return true;
        }

		if (chstandinfo !== void && chstandinfo.allDressNameMap[cmd] !== void) {
			setDress(cmd,elm);
			return true;
        }
        
        return false;
    }
	
    /**
	 * ポーズ指定処理用
     */
    function doPoseCommand(cmd, param, elm) {

        if (cmd == "pose") {
			setPose(param, elm);
			return true;
        }

		if (currentPoseNameMap[cmd] !== void) {
			setPose(cmd,elm);
			return true;
        }
        
        return false;
    }

    /**
	 * 差分指定処理用
     */
    function doDiffCommand(cmd, param, elm) {

        if (cmd == "diff") {
			setDiff(param, elm);
			return true;
        }

		if (currentDiffNameMap[cmd] !== void) {
			setDiff(cmd,elm);
			return true;
        }
        
        return false;
    }
	
    /**
	 * 表情指定コマンド処理
     */
	function doFaceCommand(cmd, param, elm) {
		
		if (cmd == "face") {
			setFace(param, elm);
			return true;
        }

		if (currentFaceNameMap[cmd] !== void) {
			setFace(cmd,elm);
			return true;
        }
        
		return false;
    }

    /**
	 * 表情指定コマンド処理
     */
	function doAddCommand(cmd, param, elm) {
		if (cmd == "add" || cmd == "addimage") {
			setAdd(param, elm);
			return true;
		}
		var info = getStandInfo(pose);
		if (info !== void && info.addMap[cmd] !== void) {
			setAdd(cmd,elm);
			return true;
		}
		return false;
    }

    /**
	 * 表情指定コマンド処理
     */
	function doAddFaceCommand(cmd, param, elm) {
		if (cmd == "addface") {
			setAddFace(param, elm);
			return true;
		}
		return false;
    }
	
    /**
	 * 表情指定コマンド処理
     */
    function doAnimCommand(cmd, param, elm) {
		if (chstandanim !== void && chstandanim[cmd] !== void) {
			stopAnim();
			animCmd = cmd;
			startAnim(chstandanim[cmd]);
			ret = kag.waitFunc(elm, waitAnim);
			return true;
		}
		return false;
    }

	var faceAnimeCommands = [];

	function initFaceAnime() {
		faceAnimeCommands.clear();
	}

	function addFaceAnime(param) {
		faceAnimeCommands.add(param);
	}
	
	// 表情変更時に一旦目を閉じる処理を追加させる処理
	function doneFaceAnime(elm) {

		if (faceAnimeCommands.count == 0) {
			return;
		}
		
		//dm("目とじアニメ実行");
		// 目のアニメ処理を一時停止
		setEyeState(-1, elm);
		animCmd = void;
		animInfo = [];
		// 目を閉じる処理を直接アニメ実行
		if (eyeLevel !== void && eyeLevel > 0) {
			for (var i=eyeLevel-1;i>=0;i--) {
				animInfo.add(%[name:"eyelevel", time:eyeflipTime, level:i]);
			}
		}
		// 表情変更を追加
		// この中で通常ステートは6になる
		var faceCmd = "";
		for (var i=0;i<faceAnimeCommands.count;i++) {
			if (i != 0) {
				faceCmd += " ";
			}
			faceCmd += faceAnimeCommands[i];
		}
		// アニメ同期
		animInfo.add(%[name:faceCmd, time:0]);
		animInfo.add(%[name:"sync", time:0]);
		// ステート指定を追加
		if (elm.eyeopen || elm.eyeopento) {
			animInfo.add(%[name:"eyestate", state:4, time:0]);
		} else if (elm.eyeclose || elm.eyecloseto) {
			animInfo.add(%[name:"eyestate", state:2, time:0]);
		}
		delete elm.eyeopen;
		delete elm.eyeclose;
		delete elm.eyeopento;
		delete elm.eyecloseto;
		if (elm.lipopen || elm.lipopento) {
			animInfo.add(%[name:"lipstate", state:4, time:0]);
		} else if (elm.lipclose || elm.lipcloseto) {
			animInfo.add(%[name:"lipstate", state:2, time:0]);
		}
		delete elm.lipopen;
		delete elm.lipclose;
		delete elm.lipopento;
		delete elm.lipcloseto;
		// アニメ開始
		animCur = 0;
		animStartTime = void;
		startUpdateHandler();
		
		ret = kag.waitFunc(elm, waitAnim);
	}

	// 表情変更判定
	function doFaceAnimeCommand(cmd, param, elm) {
		if (cmd == "xface") {
			addFaceAnime(param);
			return true;
		}
		if (cmd.charAt(0) == "x") {
			cmd = cmd.substr(1);
			if (currentFaceNameMap[cmd] !== void) {
				addFaceAnime(cmd);
				return true;
			}
		}
		return false;
	}
	
	var exCharCommands = %[
	image   : this.setImage incontextof this,
	eyeflipoff : function(param, elm) {setEyeState(0, elm);} incontextof this,
	eyeopen    : function(param, elm) {setEyeState(1, elm);} incontextof this,
	eyeclose   : function(param, elm) {setEyeState(2, elm);} incontextof this,
	eyeflipon  : function(param, elm) {setEyeState(6, elm);} incontextof this,
	eyeopento  : function(param, elm) {setEyeState(4, elm); ret=kag.waitFunc(elm, waitEyeOpen);} incontextof this,
	eyecloseto : function(param, elm) {setEyeState(5, elm); ret=kag.waitFunc(elm, waitEyeClose);} incontextof this,
	eyeflip : function(param, elm) { eyeflip=+param; setEyeState(1, elm); ret=kag.waitFunc(elm, waitEyeFlip); } incontextof this,
	lipflipoff : function(param, elm) {setLipState(0, elm);} incontextof this,
	lipopen    : function(param, elm) {setLipState(1, elm);} incontextof this,
	lipclose   : function(param, elm) {setLipState(2, elm);} incontextof this,
	lipflipon  : function(param, elm) {setLipState(6, elm);} incontextof this,
	lipopento  : function(param, elm) {setLipState(4, elm); ret=kag.waitFunc(elm, waitLipOpen);} incontextof this,
	lipcloseto : function(param, elm) {setLipState(5, elm); ret=kag.waitFunc(elm, waitLipClose);} incontextof this,
	lipflip : function(param, elm) { lipflip=+param; setLipState(0, elm); ret=kag.waitFunc(elm, waitLipFlip); } incontextof this,
	fliptime : null,
		];
	
    /**
     * コマンドの実行
     * @param cmd コマンド
     * @param param パラメータ
     * @param elm 他のコマンドも含む全パラメータ
     * @return 実行が行われた場合 true
     */
    function doCommand(cmd, param, elm) {

        if (global.KAGEnvImage.doCommand(cmd, param, elm)) {
            return true;
        }

        var func;
		if ((func = exCharCommands[cmd]) !== void) {
            if (func != null) {
                func(param, elm);
            }
            return true;
        }
		
        var func;
        if ((func = charCommands[cmd]) !== void) {
            if (func != null) {
                func(param, elm);
            }
            return true;
        }
        
		var info;
		var find = false;

		var posName = getTo(cmd);
		if (!find && env.positions !== void && env.positions[posName] !== void) {
			setPosition(cmd, elm);
            find = true;
        }            

        // アクション
        if (!find) {
            find = setAction(cmd, elm);
        }

        // エモーション
        if (!find) {
			find = setEmotion(cmd, elm);
        }
        
        // 更新
        if (!find) {
            find = setTrans(cmd, elm);
        }
        
        return find;
    };

	function _doPoseFaceCommandOne(func, names, i, e) {
		var name = names[i];
		if (name != "" && func(name, names[i+1], e)) {
			names[i] = void;
			delete e[name];
			return true;
		}
	}

	function doPoseFaceCommand(e, stop=false) {
		var names = [], name, count;
		var dress = 0, pose = 0, diff = 0, face = 0;

		// 服装指定コマンドの処理
		names.assign(e);
		count = names.count;
		for (var i=0; i<count; i+=2) if (_doPoseFaceCommandOne(doDressCommand, names, i, e)) dress++;

		// ポーズ指定コマンドの処理
		names.assign(e);
		count = names.count;
		for (var i=0; i<count; i+=2) if (_doPoseFaceCommandOne(doPoseCommand,  names, i, e)) pose++;

		// 差分指定コマンドの処理
		names.assign(e);
		count = names.count;
		for (var i=0; i<count; i+=2) if (_doPoseFaceCommandOne(doDiffCommand,  names, i, e)) diff++;

		// 表情指定コマンドの処理
		names.assign(e);
		count = names.count;
		for (var i=0; i<count; i+=2) if (_doPoseFaceCommandOne(doFaceCommand,    names, i, e)) face++;

		// 表情指定アニメコマンドの処理
		names.assign(e);
		count = names.count;
		initFaceAnime();
		for (var i=0; i<count; i+=2) if (_doPoseFaceCommandOne(doFaceAnimeCommand, names, i, e)) face++;
		
		// 追加パーツ指定コマンドの処理
		names.assign(e);
		count = names.count;
		for (var i=0; i<count; i+=2) if (_doPoseFaceCommandOne(doAddCommand, names, i, e)) face++;

		// 追加表情指定コマンドの処理
		names.assign(e);
		count = names.count;
		for (var i=0; i<count; i+=2) if (_doPoseFaceCommandOne(doAddFaceCommand, names, i, e)) face++;
		
		if (dress > 1 || pose > 1 || diff > 1) {
			var tags = [];
			tags.add("服装")   if (dress > 1);
			tags.add("ポーズ") if (pose  > 1);
			tags.add("差分")   if (diff  > 1);
			exStandError(tags.join("/")+"が多重指定されています。結果不定です。");
		}

		// 一つでも更新対象がある場合はアニメ停止
		if (stop && (dress > 0 || pose > 0 || diff > 0 || face > 0)) {
			stopAnim();
			stopUpdateHandler();
		}
		
		// 特殊目ぱちアニメ処理開始
		doneFaceAnime(e);
	}
	

	/**
	 * KAG タグ処理
	 * @param elm コマンドパラメータ
	 */
	function command(elm) {
		var e = %[];
		(Dictionary.assign incontextof e)(elm); 

		//stopAnim();
		//stopUpdateHandler();
		
		// ポーズ・表情系
		doPoseFaceCommand(e, true);

		// アニメ処理
		var names = [];
		names.assign(e);
		for (var i=0; i<names.count; i+= 2) {
			if (doAnimCommand(names[i], names[i+1], e)) {
				delete e[names[i]];
			}
		}
		
		// その他のコマンドを処理
		global.KAGEnvImage.command(e);

		// 描画時は表示レベル初期化
		if (redraw) {
			initEyeLip();
		}
	}

	// ----------------------------------------------------------------

	// 目ぱち口ぱく用パラメータ
	var lipLevel;
	var eyeLevel;
	
	/**
	 * 立ち絵の描画
	 * @param layer 描画対象レイヤ
	 * @param levelName レベル名
     * @param pose ポーズ指定
     * @oaram face 顔描画を示すフラグ
     * @return 成功したら true
     */
    function _drawLayerPose(layer, levelName, pose) {
		//dm(name + " ぽーず:" + pose + ":" + levelName);
		
		if (pose !== void && dress !== void && diff !== void && face !== void) {

			// レイヤ組み替え
			if (standlayer === void || standlayer.poseName != pose || standlayer.level != level) {
				invalidate standlayer if standlayer !== void;
				standlayer = createStandLayer(pose, level);
			}
			standlayer.setDress(dress);
			standlayer.setDiff(diff);
			standlayer.setAdd(addimage, true);
			standlayer.setAddFace(addface, true);
			standlayer.setLipLevel(lipLevel);
			standlayer.setEyeLevel(eyeLevel);
			standlayer.setFace(face);
			
			var levelInfo = env.levels[level];
			var imgzoom = levelInfo.imgzoom !== void ? levelInfo.imgzoom : 100;
			
			// オフセット指定調整
			var standinfo = chstandinfo.map[pose];
			xoffset = 0;
			yoffset = 0;
			
			// レベル/ポーズ別補正
			var levels;
			if (chstandlevel !==void &&
				((levels = chstandlevel[pose]) !== void ||
				 (levels = chstandlevel["*"]) !== void) &&
				level < levels.count) {
				yoffset -= (levels[level].y * 100 / levelInfo.zoom);
				xoffset += (levels[level].x * 100 / levelInfo.zoom);
			}
			layer.type = ltAlpha;
			var z; // 画像拡大縮小処理
			if (standlayer.imageLevel === void) {
				// 基準サイズからの拡大/縮小
				z = imgzoom;
			} else if (standlayer.imageLevel == level) {
				// 縮小済み素材
				z = 100;
			} else {
				// 最も近い素材からの縮小
				var levelInfo2 = env.levels[standlayer.imageLevel];
				var imgzoom2 = levelInfo2.imgzoom !== void ? levelInfo2.imgzoom : 100;
				z = imgzoom * 100.0 / imgzoom2;
			}
			{
				//var xoff = standinfo.xoffset * levelInfo.zoom / 100;
				//var yoff = standinfo.yoffset * levelInfo.zoom / 100;
				layer.assignImages(standlayer);
				layer.resolution = 10000 / z;
				var xoff = standinfo.xoffset * levelInfo.zoom / imgzoom;
				var yoff = standinfo.yoffset * levelInfo.zoom / imgzoom;
				afx = defaultAfx = (int)((standlayer.pageWidth/2 - standlayer.offsetX - xoff) * z / 100);
				afy = defaultAfy = (int)((standlayer.pageHeight/2 - standlayer.offsetY - yoff) * z / 100);
				//dm("width:%d height:%d afx:%s afy:%s".sprintf(layer.width, layer.height, afx, afy));
			}
			//dm("元のサイズ:" + standlayer.imageWidth + "," + standlayer.imageHeight);
			//dm("解像度:" + layer.resolution);
			//dm("変換後サイズ:" + layer.imageWidth + "," + layer.imageHeight);
			return true;
		} else {
			dm("立ち絵が表示できません chname:" + name + " pose:" + pose + " dress:" + dress + " diff:" + diff + " face:" + face);
		}
    }

	// 初期表示時にレベル初期化
	property disp {
		getter() {
			return *(&global.KAGEnvCharacter.disp incontextof this);
		}
		setter(v) {
			*(&global.KAGEnvCharacter.disp incontextof this) = v;
		}
	}

	// -----------------------------------------------------------------
	// 立ち絵情報参照用
	// -----------------------------------------------------------------

	/**
	 * 顔領域を取得する
	 */
	function getFaceArea(standlayer) {
		var faceArea = init.faceArea;
		var tag = (faceArea !== void && faceArea.name != "") ? faceArea.name : "顔領域";
		var info = standlayer.getPropInfo(dress + tag);
		if (info === void) {
			info = standlayer.getPropInfo(tag);
			//dm("通常顔領域");
		}
		if (info === void &&      (faceArea !== void || env.envinfo.faceArea !== void)) {
			var fca = (env.envinfo.faceArea !== void) ? env.envinfo.faceArea : %[];
			(Dictionary.assign incontextof fca)(faceArea, false) if (faceArea !== void);
			var point = getFacePoint(standlayer, fca);
			if (point !== void) {
				var x = point.left + fca.xoffset, y = point.top + fca.yoffset, w = fca.width, h = fca.height;
				if (fca.center) x += point.width\2, y += point.height\2;
				info = %[left:x-w\2, top:y-h\2, width:w, height:h];
			}
		}
		return info;
	}
	/**
	 * 顔原点を取得する
	 */
	function getFacePoint(standlayer, fca) {
		return standlayer.getPropInfo(fca.name != "" ? fca.name : "顔原点");
	}

    /**
     * 表情を描画する
     */
    function drawFace(layer, faceLevelName) {
		// faecLevelName上書き
		if (init.faceLevelName !== void) faceLevelName = init.faceLevelName;
		//dm("表情描画:" + name + " face:" + face + " layer:" + layer.name + " level:" + faceLevelName);
		if (pose !== void && dress !== void && diff !== void && face !== void) {
			var standInfo = getStandInfo(pose);
			if (facelayer === void || facelayer.poseName != pose || facelayer.level != faceLevelName) {
				invalidate facelayer if facelayer !== void;
				facelayer = createStandLayer(pose, faceLevelName);
			}
			var info = getFaceArea(facelayer);
			if (info !== void) {
				//dm("顔領域:%d %d %d %d".sprintf(info.left, info.top, info.width, info.height));
				var d;
				var diffMap;
				if (init.faceDiffMap !== void &&
					(diffMap = init.faceDiffMap[pose]) !== void &&
					diffMap[diff] !== void) { 
					d = diffMap[diff];
				} else {
					d = diff;
				}
				//dm("差分指定 %s -> %s".sprintf(diff, d));
				facelayer.setDress(dress);
				facelayer.setDiff(d);
				facelayer.setAdd(addimage, true);
				facelayer.setAddFace(addface, true);
				facelayer.setLipLevel(lipLevel);
				facelayer.setEyeLevel(eyeLevel);
				facelayer.setFace(face);
				facelayer.updateImage();

				// faceLayerがRelativeLayer前提
				//dm("%s:表情表示 %d %d %d".sprintf(name, standInfo.facexoff, standInfo.faceyoff, standInfo.facezoom));
				
				var left  = info.left + standInfo.facexoff;
				var top   = info.top;
				var width = info.width;
				var height = info.height + standInfo.faceyoff;
				var ox, oy, px, py;
				
				if (left < 0) {
					width -= (ox = -left);
					left = 0;
				}
				if (top < 0) {
					height -= (oy = -top);
					top = 0;
				}
				if (left+width >= facelayer.width) {
					width -= (px = (left+width - facelayer.width));
				}
				if (top+height >= facelayer.height) {
					height -= (py = (top+height - facelayer.height));
				}
				
				var dwidth = width * standInfo.facezoom / 100.0;
				var dheight = height * standInfo.facezoom / 100.0;
				var envfz = init.faceZoom !== void ? init.faceZoom : env.envinfo.faceZoom;
				if (envfz !== void) {
					var z = envfz / 100.0;
					dwidth  *= z;
					dheight *= z;
					ox *= z, oy *= z, px *= z, py *= z;
				}
				//dm("%s:表情表示 %d %d %d %d  %d %d\n".sprintf(name,left,top,width,height, facelayer.width, facelayer.height));
				
				with (layer) {
					.setImageSize(dwidth + ox+px, dheight + oy+py);
					.setSizeToImageSize();
					.repos() if (typeof .repos == "Object");
					.fillRect(0,0,.width,.height,0);
					if (envfz < 50) {
						.shrinkCopy(ox, oy, dwidth, dheight, facelayer, left, top, width, height);
					} else {
						.stretchCopy(ox, oy, dwidth, dheight, facelayer, left, top, width, height, stCubic);
					}
				}

				if (env.envinfo.faceApplyColor) {
					applyColor(layer);
				}
				layer.visible = true;
			} else {
				dm("表情描画:顔領域情報取得失敗");
				layer.visible = false;
			}
		} else {
            layer.visible = false;
        }
    }
	
	// -----------------------------------------------------------------
	// 立ち絵情報参照用
	// -----------------------------------------------------------------

	// 服装名前一覧取得
	function getDressNames(limit) {
		return chstandinfo !== void ? chstandinfo.allDressNameList : [];
	}

	// ポーズ名前一覧取得
	function getPoseNames(limit) {
		return currentPoseNameList;
	}
	
	// 表情名前一覧取得
	function getDiffNames(limit) {
		if (limit) {
			var ret = [];
			var info = getStandInfo(pose);
			var dressInfo = info.dressMap[dress];
			for (var i=0;i<dressInfo.diffList.count;i++) {
				ret.add(dressInfo.diffList[i].name);
			}
			return ret;
		} else {
			return currentDiffNameList;
		}
	}
	
	// 表情名前一覧取得
	function getFaceNames(limit) {
		if (limit) {
			var ret = [];
			var info = getStandInfo(pose);
			// 表情指定
			for (var i=0;i<info.faceList.count;i++) {
				ret.add(info.faceList[i].name);
			}
			// 表情グループ指定名
			for (var i=0;i<info.fgNameList.count;i++) {
				ret.add(info.fgNameList[i].name);
			}
			// 表情エイリアス指定
			for (var i=0;i<info.fgAliasList.count;i++) {
				ret.add(info.fgAliasList[i].name);
			}
			return ret;
		} else {
			return currentFaceNameList;
		}
	}

	// -----------------------------------------------------------------
	// 特殊アニメ処理
	// -----------------------------------------------------------------

	var animCmd;
	var animInfo;  // アニメーション用情報
	var animCur;       // 現在実行中のアニメ部分
	var animStartTime; // アニメ起動時間
	var animNextTime;  // 次の表示タイミング

	/**
	 * アニメーション状態更新用
	 */
	function updateAnim(tick) {
		var update = false;
		if (animStartTime === void) {
			animStartTime = tick;
			animNextTime = 0;
		}
		var animTime = tick - animStartTime;
		var newimage;
		var sync = false;
		while (animTime >= animNextTime) {
			if (sync) {
				break;
			}
			if (animCur >= animInfo.count) {
				stopAnim();
				break;
			}
			var info = animInfo[animCur];
			//dm("アニメ更新:" + animCur + ":" + info.name);
			switch (info.name) {
			case "loop":
				if (info.time < animInfo.count) {
					animCur = +info.time;
				} else {
					stopAnim();
					return;
				}
				continue;
			case "wait":
				animNextTime += info.time;
				animCur++;
				break;
			case "eyelevel":
				animNextTime += info.time;
				if (eyeLevel != info.level) {
					eyeLevel = info.level;
					update = true;
				}
				animCur++;
				break;
			case "liplevel":
				animNextTime += info.time;
				if (lipLevel != info.level) {
					lipLevel = info.level;
					update = true;
				}
				animCur++;
				break;
			case "sync":
				//強制同期用
				animCur++;
				sync = true;
				break;
			case "eyestate":
				setEyeState(info.state);
				animCur++;
				break;
			case "lipstate":
				setLipState(info.state);
				animCur++;
				break;
			default:
				newimage = info.name;
				animNextTime += info.time;
				animCur++;
				break;
			}
		}
		if (newimage !== void) {
			// 更新実行
			trans = %[];
			var e = %[];
			var commands = [];
			commands.split(" ", newimage);
			for (var i=0;i<commands.count;i++) {
				var cmd = commands[i];
				var n;
				if ((n =cmd.indexOf('=')) > 0) {
					e[cmd.substring(0,n)] = cmd.substring(n+1);
				} else {
					e[cmd] = true;
				}
			}
			//dm("アニメ実行:" + newimage);
			doPoseFaceCommand(e);
			update = true;
		}
		return update;
    }

	/*
	 * アニメ停止
	 */
	function stopAnim() {
		animCmd = void;
		animInfo = void;
		animStartTime = void;
		kag.trigger(name + "_anim");
	}

	/**
	 * アニメ処理の開始
	 * @param アニメ情報
	 */
	function startAnim(list) {
		animInfo = [];
		animCur = 0;
		animStartTime = void;
		for (var i=0;i<list.count;i++) {
			var val  = list[i];
			var info = %[name:val[0], time:+val[1]];
			animInfo.add(info);
		}
		if (animInfo.count > 0) {
			if (!startUpdateHandler()) {
			}
		}
	}

	// アニメを待てるか
	function canWaitAnim() {
		if (animInfo === void) return false;
		for (var i=0;i<animInfo.count;i++) {
			if (animInfo[i].name == "loop") {
				return false;
			}
		}
		return true;
	}
	
	function waitAnim(elm) {
		if (canWaitAnim()) {
			var canskip = elm.canskip !== void ? elm.canskip : true;
			if (canskip && kag.clickSkipEnabled) {
				if(kag.skipMode){
					stopAnim();
					return 0;
				}
				kag.conductor.wait(%[
				    click : function(arg)
					{
						arg();
					} incontextof this,
					click_arg : stopAnim,
					elm.name => function(arg)
					{
						return arg;
					} incontextof this,
					elm.name + "_arg" => +elm.wait
						]);
			} else {
				kag.conductor.wait(%[
					elm.name => function(arg)
					{
						return arg;
					} incontextof this,
					elm.name + "_arg" => +elm.wait
						]);
			}
			return -2;
		} else {
			return 0;
		}
	}
	
	// ---------------------------------------------
	// 目ぱち口ぱく処理
	// ---------------------------------------------

	// 強制目ぱち。指定回数繰り返す
	var eyeflip;
	var eyeflipTime;

	// 強制口ぱく。指定回数繰り返す
	var lipflip;
	var lipflipTime;
	
	// 目の状態
	// 0:デフォルト 1:開く 2:閉じる 3:目ぱち 4:開く状態に移行 5:閉じる状態に移行 6:開いた後目ぱち -1:何もしない
	var eyestate = 0;

	// 口の状態
	// 0:デフォルト 1:開く 2:閉じる 3:口ぱく 4:開く状態に移行 5:閉じる状態に移行 6:閉じた後口ぱく -1:何もしない
	var lipstate = 0;

	// 目パチ用
	var eyePatterns = [2,1,0,1,2];
	
	// 目ぱち用制御
	var eyePattern;

	// 口ぱく用
	var lipPatterns = [0,1,2,1,0];
	
	// 目ぱく制御
	var lipPattern;
	
	// タイミング制御用
	var flipEyeNextTime;
	var flipLipNextTime;

	function initEyeLip() {
		switch (eyestate) {
		case 0: // デフォルト
			if (eyeLevel !== void) {
				eyeLevel = void;
			}
			break;
		case 1: // 開く
		case 3:
		case 4:
		case 6:
			if (eyeLevel !== 2) {
				eyeLevel = 2;
			}
			break;
		case 2: // 閉じる
		case 5:
			if (eyeLevel !== 0) {
				eyeLevel = 0;
			}
			break;
		}
		switch (lipstate) {
		case 0: // デフォルト
			if (lipLevel !== void) {
				lipLevel = void;
			}
			break;
		case 1: // 開く
		case 4:
			if (lipLevel !== 2) {
				lipLevel = 2;
			}
			break;
		case 2: // 閉じる
		case 3:
		case 5:
		case 6:
			if (lipLevel !== 0) {
				lipLevel = 0;
			}
			break;
		}
	}

	/**
	 * 目ぱち状態の更新
	 */
	function updateEye(tick) {
		var updateFlag = false;
		
		// 強制まばたき処理
		if (eyeflip > 0) {
			//dm("強制瞬き処理!");
			if (eyePattern === void) {
				eyePattern = 0;
			} else {
				var level = eyePatterns[eyePattern++];
				if (eyeLevel !== level) {
					eyeLevel = level;
					updateFlag = true;
				}
				if (eyePattern >= eyePatterns.count) {
					eyePattern = void;
					eyeflip--;
					if (eyeflip == 0) {
						kag.trigger(name + "_eyeflip");
					}
				}
			}
			return updateFlag;
		}
		
		// 目ぱち用処理
		switch (eyestate) {
		case 0: // デフォルト
			if (eyeLevel !== void) {
				eyeLevel = void;
				updateFlag = true;
			}
			break;
		case 1: // 開く
			if (eyeLevel !== 2) {
				eyeLevel = 2;
				updateFlag = true;
			}
			break;
		case 2: // 閉じる
			if (eyeLevel !== 0) {
				eyeLevel = 0;
				updateFlag = true;
			}
			break;
		case 3: // アニメ
			if (eyePattern === void) {
				// ランダムで目ぱちするかどうか決定
				if (Math.random() < eyeFlipFreq) {
					eyePattern = 0;
					//dm("目ぱち開始");
				}
			} else {
				var level = eyePatterns[eyePattern++];
				if (eyeLevel !== level) {
					eyeLevel = level;
					updateFlag = true;
				}
				if (eyePattern >= eyePatterns.count) {
					eyePattern = void;
					//dm("目ぱち終了");
				}
			}
			break;
		case 4: // 開く状態に移行
			switch (eyeLevel) {
			case 0:
				eyeLevel = 1;
				updateFlag = true;
				break;
			default:
				if (eyeLevel !== 2) {
					eyeLevel = 2;
					updateFlag = true;
				} else {
					eyestate = 1;
					kag.trigger(name + "_eyeopen");
				}
				break;
			}
			break;
		case 5: // 閉じる状態に移行
			switch (eyeLevel) {
			case 2:
				eyeLevel = 1;
				updateFlag = true;
				break;
			default:
				if (eyeLevel !== 0) {
					eyeLevel = 0;
					updateFlag = true;
				} else {
					eyestate = 2;
					kag.trigger(name + "_eyeclose");
				}
				break;
			}
			break;
		case 6: // 開いたあと目ぱち
			switch (eyeLevel) {
			case 0:
				eyeLevel = 1;
				updateFlag = true;
				break;
			default:
				if (eyeLevel !== 2) {
					eyeLevel = 2;
					updateFlag = true;
				} else {
					eyestate = 3;
					eyePattern = void;
					kag.trigger(name + "_eyeopen");
				}
				break;
			}
			break;
		}
		return updateFlag;
	}

	/**
	 * 目ぱち状態の更新
	 */
	function updateLip(tick) {
		var updateFlag = false;

		// 強制処理
		if (lipflip > 0) {
			//dm("強制瞬き処理!");
			if (lipPattern === void) {
				lipPattern = 0;
			} else {
				var level = lipPatterns[lipPattern++];
				if (lipLevel !== level) {
					lipLevel = level;
					updateFlag = true;
				}
				if (lipPattern >= lipPatterns.count) {
					lipPattern = void;
					lipflip--;
					if (lipflip == 0) {
						kag.trigger(name + "_lipflip");
					}
				}
			}
			return updateFlag;
		}
		
		switch (lipstate) {
		case 0: // デフォルト
			if (lipLevel !== void) {
				lipLevel = void;
				updateFlag = true;
			}
			break;
		case 1: // 開く
			if (lipLevel !== 2) {
				lipLevel = 2;
				updateFlag = true;
			}
			break;
		case 2: // 閉じる
			if (lipLevel !== 0) {
				lipLevel = 0;
				updateFlag = true;
			}
			break;
		case 3: // アニメ
			// 音量レベルを取得して設定
			if (!kag.historyShowing) {
				var voiceLevel;
				//dm("サウンドバッファ:" + soundBuffer);
				if (soundBuffer !== void && soundBuffer.status == "play") {
					if (WaveSoundBuffer.enableGetSample) {
						var a = soundBuffer.sampleValue;
						//dm("ボイス値: "+soundBuffer.position+" : %0.3f".sprintf(a));
						if (a > 0.2) {
							voiceLevel = 2;
						} else if (a > 0.01) {
							voiceLevel = 1;
						} else {
							voiceLevel = 0;
						}
					} else {
						// とりあえずランダム対応
						voiceLevel = (int)(Math.random() * 3);
					}
				}
				if (lipLevel !== voiceLevel) {
					lipLevel = voiceLevel;
					updateFlag = true;
				}
			}
			break;
		case 4: // 開く状態に移行
			switch (lipLevel) {
			case 0:
				lipLevel = 1;
				updateFlag = true;
				break;
			default:
				if (lipLevel !== 2) {
					lipLevel = 2;
					updateFlag = true;
				} else {
					lipstate = 1;
					kag.trigger(name + "_lipopen");
				}
				break;
			}
			break;
		case 5: // 閉じる状態に移行
			switch (lipLevel) {
			case 2:
				lipLevel = 1;
				updateFlag = true;
				break;
			default:
				if (lipLevel !== 0) {
					lipLevel = 0;
					updateFlag = true;
				} else {
					lipstate = 2;
					kag.trigger(name + "_lipclose");
				}
				break;
			}
			break;
		case 6: // 閉じた後口ぱく
			switch (lipLevel) {
			case 2:
				lipLevel = 1;
				updateFlag = true;
				break;
			default:
				if (lipLevel !== 0) {
					lipLevel = 0;
					updateFlag = true;
				} else {
					lipstate = 3;
					lipPattern = void;
					kag.trigger(name + "_lipclose");
				}
				break;
			}
			break;
		}
		return updateFlag;
	}

	function waitEyeOpen(elm) {
		if (eyestate == 4) {
			var canskip = elm.canskip !== void ? elm.canskip : true;
			var name = this.name + "_eyeopen";
			if (canskip && kag.clickSkipEnabled) {
				if(kag.skipMode){
					eyestate = 1;
					return 0;
				}
				kag.conductor.wait(%[
				    click : function(arg)
					{
						eyestate = 1;
					} incontextof this,
					click_arg : stopAnim,
					name => function(arg)
					{
						return arg;
					} incontextof this,
					name + "_arg" => +elm.wait
						]);
			} else {
				kag.conductor.wait(%[
					name => function(arg)
					{
						return arg;
					} incontextof this,
					name + "_arg" => +elm.wait
						]);
			}
			return -2;
		} else {
			return 0;
		}
	}

	function waitLipOpen(elm) {
		if (lipstate == 4) {
			var canskip = elm.canskip !== void ? elm.canskip : true;
			var name = this.name + "_lipopen";
			if (canskip && kag.clickSkipEnabled) {
				if(kag.skipMode){
					lipstate = 1;
					return 0;
				}
				kag.conductor.wait(%[
				    click : function(arg)
					{
						lipstate = 1;
					} incontextof this,
					click_arg : stopAnim,
					name => function(arg)
					{
						return arg;
					} incontextof this,
					name + "_arg" => +elm.wait
						]);
			} else {
				kag.conductor.wait(%[
					name => function(arg)
					{
						return arg;
					} incontextof this,
					name + "_arg" => +elm.wait
						]);
			}
			return -2;
		} else {
			return 0;
		}
	}

	function waitEyeClose(elm) {
		if (eyestate == 5) {
			var canskip = elm.canskip !== void ? elm.canskip : true;
			var name = this.name + "_eyeclose";
			if (canskip && kag.clickSkipEnabled) {
				if(kag.skipMode){
					eyestate = 2;
					return 0;
				}
				kag.conductor.wait(%[
				    click : function(arg)
					{
						eyestate = 2;
					} incontextof this,
					click_arg : stopAnim,
					name => function(arg)
					{
						return arg;
					} incontextof this,
					name + "_arg" => +elm.wait
						]);
			} else {
				kag.conductor.wait(%[
					name => function(arg)
					{
						return arg;
					} incontextof this,
					name + "_arg" => +elm.wait
						]);
			}
			return -2;
		} else {
			return 0;
		}
	}

	function waitLipClose(elm) {
		if (lipstate == 5) {
			var canskip = elm.canskip !== void ? elm.canskip : true;
			var name = this.name + "_lipclose";
			if (canskip && kag.clickSkipEnabled) {
				if(kag.skipMode){
					lipstate = 2;
					return 0;
				}
				kag.conductor.wait(%[
				    click : function(arg)
					{
						lipstate = 2;
					} incontextof this,
					click_arg : stopAnim,
					name => function(arg)
					{
						return arg;
					} incontextof this,
					name + "_arg" => +elm.wait
						]);
			} else {
				kag.conductor.wait(%[
					name => function(arg)
					{
						return arg;
					} incontextof this,
					name + "_arg" => +elm.wait
						]);
			}
			return -2;
		} else {
			return 0;
		}
	}

	function waitEyeFlip(elm) {
		if (eyeflip > 0) {
			var canskip = elm.canskip !== void ? elm.canskip : true;
			var name = this.name + "_eyeflip";
			if (canskip && kag.clickSkipEnabled) {
				if(kag.skipMode){
					eyeflip = 0;
					return 0;
				}
				kag.conductor.wait(%[
				    click : function(arg)
					{
						eyeflip = 0;
					} incontextof this,
					click_arg : stopAnim,
					name => function(arg)
					{
						return arg;
					} incontextof this,
					name + "_arg" => +elm.wait
						]);
			} else {
				kag.conductor.wait(%[
					name => function(arg)
					{
						return arg;
					} incontextof this,
					name + "_arg" => +elm.wait
						]);
			}
			return -2;
		} else {
			return 0;
		}
	}

	function waitLipFlip(elm) {
		if (lipflip > 0) {
			var canskip = elm.canskip !== void ? elm.canskip : true;
			var name = this.name + "_lipflip";
			if (canskip && kag.clickSkipEnabled) {
				if(kag.skipMode){
					lipflip = 0;
					return 0;
				}
				kag.conductor.wait(%[
				    click : function(arg)
					{
						lipflip = 0;
					} incontextof this,
					click_arg : stopAnim,
					name => function(arg)
					{
						return arg;
					} incontextof this,
					name + "_arg" => +elm.wait
						]);
			} else {
				kag.conductor.wait(%[
					name => function(arg)
					{
						return arg;
					} incontextof this,
					name + "_arg" => +elm.wait
						]);
			}
			return -2;
		} else {
			return 0;
		}
	}

	// 目ぱち状態の指定
	function setEyeState(state, elm){
		//dm("目ステート指定:" + state);
		eyeflipTime = elm !== void && elm.fliptime !== void ? +elm.fliptime : eyeFlipTime;
		if (kag.drawspeed > 0 || state != 3) {
			eyestate = state;
			startUpdateHandler();
		}
	}
	
	// 口ぱく状態の指定
	function setLipState(state, elm) {
		lipflipTime = elm !== void && elm.fliptime !== void ? +elm.fliptime : lipFlipTime;
		if (kag.drawspeed > 0 || state != 3) {
			lipstate = state;
			startUpdateHandler();
		}
	}

	/**
	 * ボイスの再生
     */
	function playVoice(voicename=void) {
		var ret = super.playVoice(voicename);
		if (ret > 0 && lipstate == 3) {
			startUpdateHandler();
		}
		return ret;
	}
	
	// --------------------------------------------

	// 表示更新はんどら
	function updateHandler(tick) {

		// 非表示の場合は何もしない
		if (!isShow() || kag.skipNoDisp) {
			return;
		}

		// トランジション中は何もしない
		if (targetLayer !== void && targetLayer.inTransition) {
			return;
		}

		var updateFlag = false;
		var updatePos  = false;

		if (flipEyeNextTime === void) {
			flipEyeNextTime = tick;
		}
		if (tick >= flipEyeNextTime) {
			if (updateEye(tick)) {
				updateFlag = true;
			}
		}
		while (flipEyeNextTime <= tick) {
			flipEyeNextTime += eyeflipTime;
		}

		if (flipLipNextTime === void) {
			flipLipNextTime = tick;
		}
		if (tick >= flipLipNextTime) {
			if (updateLip(tick)) {
				updateFlag = true;
			}
		}
		// 次のフリップどき
		while (flipLipNextTime <= tick) {
			flipLipNextTime += lipflipTime;
		}

		// アニメ処理
		if (animInfo !== void) {
			if (updateAnim(tick)) {
				updateFlag = true;
				updatePos  = true;
			}
		}

		// 画像更新
		if (updateFlag) {
			// 描画対象が表画面なら強制再描画
			if (targetLayer !== void && targetLayer.parent == kag.fore.base) {
				drawLayer(targetLayer);
				setSize(targetLayer);
				if (updatePos) {
					targetLayer.updateOffsetInfo();
				}
			}
		}

		stopUpdateHandler();
	}

	// 表示更新の停止
	function stopUpdateHandler() {
		if (animInfo === void && eyeflip <= 0 && lipflip <= 0 && eyestate < 3 && lipstate <3 && !(lipstate == 3 && soundBuffer !== void && soundBuffer.status == "play")) {
			System.removeContinuousHandler(updateHandler);
			flipEyeNextTime = void;
			flipLipNextTime = void;
		}
	}

	// 表示更新の開始
	function startUpdateHandler() {
		System.removeContinuousHandler(updateHandler);
		if (kag.drawspeed > 0) {
			System.addContinuousHandler(updateHandler);
			return true;
		}
		return false;
	}

	/**
	 * エモーション情報を返す
	 * @param emotion エモーション情報
	 * emoX, emoY, emoRev
	 */
	function getEmotionInfo(emotion) {

		var info;

		if (standlayer !== void) {
			var addflag = false;
			if (emotion !== void) {
				var name = emotion.name;
				info = standlayer.getPropInfo(name + "エモーション原点");
				if (info === void) {
					name = name.replace(/[a-zA-Z]/, ""); // 英字を消す
					info = standlayer.getPropInfo(name + "エモーション原点");
				}
			}
			if (info === void) {
				info = standlayer.getPropInfo("エモーション原点");
				addflag = true;
			}
		}

		if (info === void) {
			return super.getEmotionInfo(emotion);
		}

		var eleft, etop;
		var eorigin = emotion !== void ? emotion.origin : 1;
		switch (eorigin) {
		case 1:
			eleft = info.left;
			etop  = info.top;
			break;
		case 2:
			eleft = info.left + info.width / 2;
			etop  = info.top;
			break;
		case 3:
			eleft = info.left + info.width;
			etop  = info.top ;
			break;
		case 4:
			eleft = info.left + info.width;
			etop  = info.top  + info.height / 2;
			break;
		case 5:
			eleft = info.left + info.width;
			etop  = info.top  + info.height;
			break;
		case 6:
			eleft = info.left + info.width / 2;
			etop  = info.top  + info.height;
			break;
		case 7:
			eleft = info.left;
			etop  = info.top  + info.height;
			break;
		case 8:
			eleft = info.left;
			etop  = info.top  + info.height / 2;
			break;
		default:
			eleft = info.left + info.width / 2;
			etop  = info.top  + info.height / 2;
			break;
		}
		
		var levelInfo = env.levels[level];
		var imgzoom = levelInfo.imgzoom !== void ? levelInfo.imgzoom : 100;
		var standinfo = chstandinfo.map[pose];
		var emoRev = standinfo.emoRev;

		var z; // 画像拡大縮小処理
		if (standlayer.imageLevel === void) {
			// 基準サイズからの拡大/縮小
			z = imgzoom;
		} else if (standlayer.imageLevel == level) {
			// 縮小済み素材
			z = 100;
		} else {
			// 最も近い素材からの縮小
			var levelInfo2 = env.levels[standlayer.imageLevel];
			var imgzoom2 = levelInfo2.imgzoom !== void ? levelInfo2.imgzoom : 100;
			z = levelInfo.imgzoom * 100.0 / imgzoom2;
		}

		// エモーション座標補正
		var emoX = ((standlayer.offsetX + eleft) - standlayer.pageWidth/2) * z / levelInfo.zoom;
		var emoY = (standlayer.pageHeight -   (standlayer.offsetY + etop)) * z / levelInfo.zoom;
		//dm("エモーション情報:" + emoRev + " " + emoX + "," + emoY + "  zoom:" + z + " size:" + standlayer.width + "," + standlayer.height);
		
		// 座標調整
		if (addflag && emotion !== void) {
			emoY += emotion.yoff if emotion.yoff !== void;
			emoX += emoRev ? -emotion.xoff : emotion.xoff if emotion.xoff !== void;
		}
		
		return %[ emoX:emoX, emoY:emoY, emoRev:emoRev ];
	}

	/**
	 * エラー通知処理
	 */
	function exStandError(msg) {
		msg = name+":"+msg;
		kag.errorImage(msg);
		if (kag.debugLevel < tkdlSimple) dm(msg);
	}
};

// キャラクタ生成ロジックの書き換え
KAGEnvironment._getCharacter = function(name, initName, init) {
	return new KAGEnvCharacterEx(this, name, initName, init);
};


/**
 * ポーズがあるキャラクタ名一覧の取得
 */
KAGEnvironment.getPoseCharacterNames = function() {
	var ret = [];
	var names = [];
	names.assign(allStandInfoMap);
	for (var i=0;i<names.count;i+=2) {
		var name = names[i];
		var init = names[i+1];
		ret.add(%[name:name, initName:name]);
	}
	ret.sort(function(a,b){return a.name < b.name;});
	return ret;
};

/**
 * ポーズがあるキャラクタ名一覧の取得
 */
KAGEnvironment.getCurrentPoseCharacterNames = function() {
	var ret = [];
	var names = [];
	names.assign(characters);
	for (var i=0;i<names.count;i+=2) {
		var name = names[i];
		var ch = names[i+1];
		if (ch.chstandinfo !== void) {
			ret.add(%[name:ch.name, initName:ch.initName]);
		}
	}
	ret.sort(function(a,b){return a.name < b.name;});
	return ret;
};
